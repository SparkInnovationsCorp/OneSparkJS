/**
 * OneSparkJS JavaScript Game Engine
 * Version 1.0.0.0
 * Created by Jason Bramble
 * Copyright (c) 2023 Spark Innovations Corp
 * Licensed under the OneSparkJS License Agreement
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software
 * and associated documentation files (the "Software"), to use, copy, modify, and distribute the Software
 * in non-commercial projects subject to the following conditions:
 *
 * - The above copyright notice and this permission notice shall be included in all copies or substantial
 *   portions of the Software.
 * - Credit shall be given to "OneSparkJS by Spark Innovations Corp" in any accompanying documentation or README file.
 *
 * Permission is also granted to use, copy, modify, and distribute the Software in commercial or revenue-generating
 * projects with the explicit permission of Spark Innovations Corp. To request permission, please contact us
 * at support@sparkinnovationscorp.com.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
 * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */
((global) => {

     const OneSparkJs = {};

     // Application module
     OneSparkJs.Application = (() => {
          const version = "1.0.0";
          let lastTime = 0;
          let clockRunning = false;
          let application = null;
          let extensions = [];

          class ExtensionType {
               constructor(priority = 0) {
                    extensions.push({
                         instance: this,
                         Priority: priority
                    });

                    extensions.sort((a, b) => a.Priority - b.Priority);
               }
          }

          const load = (appPath, properties = {}, callback = null) => {

               if (!appPath.endsWith('/')) {
                    appPath += '/';
               }

               loadExtensions(appPath, properties, () => {

                    console.log("All extensions loaded."); 

                    $1S.include(`${appPath}main.js`, null, (success, errorMessage) => {
                         if (success) {
                              if (properties.autoStart)
                                   start();

                              if (callback)
                                   callback();
                         } else {
                              console.error(errorMessage);
                         }
                    });

               });

          };

          const loadExtensions = (appPath, properties, callback) => {
               var numExtensions = extensions.length;
               var numLoaded = 0;

               extensions.forEach(ext => {
                    if (ext.instance.onLoad) {
                         ext.instance.onLoad(appPath, properties, () => {
                              numLoaded++;
                              if (numLoaded === numExtensions) {
                                   callback();
                              }
                         });
                    }
               });
          };

          const start = async () => {

               const appType = await $1S.getTypeAsync("MainApp");

               if (!appType) {
                    console.error('Application not defined.');
                    return
               }

               application = new appType();

               if (application.onStart)
                    application.onStart();

               startClock();

          };

          const stop = async () => {

               if (application.onStop)
                    application.onStop();

               stopClock();

               $1S.Renderer.Canvas.clear();

               OneStartJS.Stage.reset();

          };

          const startClock = () => {
               lastTime = 0;
               clockRunning = true;
               window.requestAnimationFrame(tick);          };

          const tick = (timeStamp) => {

               let deltaTime = timeStamp - lastTime;

               if (application) {

                    //tick
                    if (application.onTick) {
                         application.onTick(timeStamp, deltaTime);
                    }

                    extensions.forEach(ext => {
                         if (ext.instance.handleTickEvent) {
                              ext.instance.handleTickEvent(timeStamp, deltaTime);
                         }                    });

                    //post tick
                    extensions.forEach(ext => {
                         if (ext.instance.handlePostTickEvent) {
                              ext.instance.handlePostTickEvent(timeStamp, deltaTime);
                         }                    });

                    if (application.onPostTick) {
                         application.onPostTick(timeStamp, deltaTime);
                    }

               }

               lastTime = timeStamp;

               if (clockRunning) {
                    window.requestAnimationFrame(tick);               }
          };

          const stopClock = () => {
               clockRunning = false;
          };

          const get = () => {
               return application;
          };

          const registerExtension = (obj, priority = 0) => {
               if (obj instanceof ExtensionType) {
                    extensions.push({
                         instance: obj,
                         Priority: priority
                    });

                    extensions.sort((a, b) => a.Priority - b.Priority);
               } else {
                    console.error('Error: obj is not an instance of ApplicationExtensionType');
               }
          };

          return {
               ExtensionType,
               version,
               load,
               start,
               stop,
               get,
               tick,
               startClock,
               stopClock,
               registerExtension
          }
     })();

     // Helper functions
     OneSparkJs.Helper = (() => {
          const newId = () => {
               let guid = '';
               for (let i = 0; i < 32; i++) {
                    guid += Math.floor(Math.random() * 16).toString(16);
                    if (i === 7 || i === 11 || i === 15 || i === 19) {
                         guid += '-';
                    }
               }
               return guid;
          };

          return {
               newId
          }
     })();

     // Module module
     OneSparkJs.Module = (() => {
          let filesLoaded = [];
          let dependencies = [];
          let types = [];

          const include = (files, parent = null, callback = null) => {
               if (typeof files === 'string') {
                    files = [files];
               } else if (!Array.isArray(files)) {
                    if (typeof callback === 'function') {
                         callback(false, "Error: 'files' parameter must be an array or a string");
                    }
                    return;
               }

               const parentFilePath = parent == null ? getParentFilePath() : parent;

               const parentPath = parentFilePath.replace(/\/[^\/]+$/, '') + "/";

               const loadScript = (file) => {

                    const url = resolveUrl(file, parentPath);

                    // add new dependency only if it does not already exist
                    const dependencyExists = dependencies
                         .some(dependency => dependency.Parent === parentFilePath && dependency.Child === file);

                    if (!dependencyExists) {
                         dependencies.push({
                              Parent: parentFilePath,
                              Child: file
                         });
                    }

                    if (filesLoaded.includes(file)) {
                         return;
                    }

                    var xhr = new XMLHttpRequest();
                    xhr.open('GET', url, true);
                    xhr.onload = function () {
                         if (xhr.status === 200) {
                              var script = xhr.responseText;

                              script = modifyIncludeCalls(script, url);

                              script = "async function factory() {\n" + script + "\n}\nfactory();";

                              try {
                                   eval(script); // Evaluate the script

                                   loadedCount++;
                                   if (!filesLoaded.includes(file)) {
                                        filesLoaded.push(file);
                                   }
                                   checkIfAllLoaded();

                              } catch (e) {
                                   console.error(`Error evaluating script in ${url}:`, e);
                                   errorCount++;
                                   checkIfAllLoaded();
                              }
                         }
                    };
                    xhr.onerror = function () {
                         console.error(`Error evaluating script in ${url}:`, xhr.statusText);
                         errorCount++;
                         checkIfAllLoaded();
                    };
                    xhr.send();
               };

               let loadedCount = 0;
               let errorCount = 0;
               let errorMessages = [];

               const checkIfAllLoaded = () => {
                    if (loadedCount + errorCount === files.length) {
                         const success = errorCount === 0;
                         const message = success ? "All files loaded successfully" : `Errors loading files: ${errorMessages.join("; ")}`;
                         callback && callback(success, message);
                    }
               };

               const modifyIncludeCalls = (script, file) => {
                    const includeStr = "$1S.include(";
                    const importStr = "$1S.import(";
                    let startIndex = 0;

                    while (true) {
                         // Find the next occurrence of the include function call
                         const includeIndex = script.indexOf(includeStr, startIndex);
                         const importIndex = script.indexOf(importStr, startIndex);
                         var index = -1;

                         if (includeIndex === -1 && importIndex === -1) {
                              break; // No more occurrences found
                         }

                         if (includeIndex != -1 && (importIndex == -1 || (importIndex != -1 && includeIndex < importIndex))) {
                              index = includeIndex;
                         }

                         if (importIndex != -1 && (includeIndex == -1 || (includeIndex != -1 && importIndex < includeIndex))) {
                              index = importIndex;
                         }

                         if (index === -1) {
                              break; // No more occurrences found
                         }

                         // Find the closing parenthesis of the function call
                         let depth = 1;
                         let end = index + includeStr.length;
                         while (depth > 0 && end < script.length) {
                              if (script.charAt(end) === "(") {
                                   depth++;
                              } else if (script.charAt(end) === ")") {
                                   depth--;
                              }
                              end++;
                         }
                         if (depth !== 0) {
                              break; // Malformed include function call
                         }

                         // Build the new function call with the updated second argument
                         const oldCall = script.slice(index, end);
                         const newCall = oldCall.slice(0, -1) + `, "${file}")`;

                         // Replace the old function call with the new one
                         script = script.slice(0, index) + newCall + script.slice(end);

                         // Update the startIndex to search for the next occurrence
                         startIndex = index + newCall.length;
                    }

                    return script;
               };

               if (files && files.length) {
                    files.forEach(loadScript);
               } else if (typeof callback === 'function') {
                    callback(true, "No files to load");
               }
          };

          const importType = async (alias, file, parent = null) => {

               include(file, parent);

               return getTypeAsync(alias);
          };

          const registerType = (type, alias) => {
               const existingType = types.find(t => t.Alias === alias);
               if (!existingType) {
                    types.push({
                         Type: type,
                         Alias: alias
                    });
               }
          };

          const getTypeAsync = async (alias) => {
               while (true) {
                    const existingType = types.find(t => t.Alias === alias);
                    if (existingType) {
                         return existingType.Type;
                    } else {
                         // Wait for 100 milliseconds before trying again
                         await new Promise(resolve => setTimeout(resolve, 100));
                    }
               }
          };

          const getType = (alias) => {

               const existingType = types.find(t => t.Alias === alias);
               if (existingType) {
                    return existingType.Type;
               } else {
                    throw new Error(`Type with alias ${alias} not found`);
               }
          };

          const getParentFilePath = () => {
               const stackTrace = (new Error().stack || '').split('\n')[3] || '';
               const filePathStartIndex = stackTrace.indexOf('/', stackTrace.indexOf('//') + 2);
               const filePathEndIndex = stackTrace.indexOf(':', filePathStartIndex);
               const parentFilePath = filePathStartIndex !== -1 && filePathEndIndex !== -1 ? stackTrace.substring(filePathStartIndex, filePathEndIndex) : '';
               return parentFilePath;
          };

          const resolveUrl = (file, parentPath) => {
               if (!file.toLowerCase().startsWith('http://') && !file.toLowerCase().startsWith('https://')) {
                    const parentUrl = new URL(parentPath, window.location.href);
                    const fileUrl = new URL(file, parentUrl);
                    file = fileUrl.pathname;
               }
               return file;
          };

          return {
               include,
               importType,
               registerType,
               getType,
               getTypeAsync
          }
     })();

     // Public API
     global.$1S = {
          Application: {
               ExtensionType: OneSparkJs.Application.ExtensionType,
               load: OneSparkJs.Application.load,
               start: OneSparkJs.Application.start,
               startClock: OneSparkJs.Application.startClock,
               stopClock: OneSparkJs.Application.stopClock,
               get: OneSparkJs.Application.get,
               registerExtension: OneSparkJs.Application.registerExtension
          },
          Helper: {
               newId: OneSparkJs.Helper.newId,
          },
          import: OneSparkJs.Module.importType,
          include: OneSparkJs.Module.include,
          registerType: OneSparkJs.Module.registerType,
          getType: OneSparkJs.Module.getType,
          getTypeAsync: OneSparkJs.Module.getTypeAsync
     };

})(typeof window !== 'undefined' ? window : global);

((global) => {

     const OneSparkJs = {};

     //Audio module
     OneSparkJs.Assets = (() => {

          class Extension extends $1S.Application.ExtensionType {

               assetSheet = {
                    audio: [],
                    images: [],
                    loops: [],
                    layouts: []
               }

               constructor() {
                    super(100);
               }

               onLoad = (appPath, properties, oncomplete) => {
                    try {
                         const path = appPath + "assets.json";
                         var xhr = new XMLHttpRequest();
                         xhr.open('GET', path, true);
                         xhr.onload = () => {
                              if (xhr.status === 200) {
                                   const json = JSON.parse(xhr.responseText);
                                   if (Array.isArray(json.audio)) {
                                        this.assetSheet.audio = json.audio;
                                        if ($1S.Audio) {
                                             this.assetSheet.audio.forEach(function (node) {
                                                  $1S.Audio.preload(node.path);
                                             });
                                        }
                                   }
                                   if (Array.isArray(json.images)) {
                                        const images = json.images;
                                        images.forEach((node) => {
                                             this.preloadImage(node);
                                        });
                                   }
                                   if (Array.isArray(json.layouts)) {
                                        this.assetSheet.layouts = json.layouts;
                                   }
                              }
                              if (oncomplete) oncomplete();
                         };
                         xhr.onerror = () => {
                              console.error(`Error loading asset sheet`, xhr.statusText);
                              if (oncomplete) oncomplete();
                         };
                         xhr.send();
                    } catch (e) {
                         console.log("Error loading asset sheet", e);
                         if (oncomplete) oncomplete();                    }
               }

               getAudio = (name) => {
                    for (let i = 0; i < this.assetSheet.audio.length; i++) {
                         if (this.assetSheet.audio[i].name === name) {
                              return this.assetSheet.audio[i];
                         }
                    }
                    return null;
               }

               getImage = (name) => {
                    for (let i = 0; i < this.assetSheet.images.length; i++) {
                         if (this.assetSheet.images[i].name === name) {
                              return this.assetSheet.images[i];
                         }
                    }
                    return null;
               }

               getSpriteLoop = (name) => {
                    for (let i = 0; i < this.assetSheet.loops.length; i++) {
                         if (this.assetSheet.loops[i].group === name) {
                              return this.assetSheet.loops[i];
                         }
                    }
                    return null;
               }

               getTileset = (name) => {

                    for (let i = 0; i < this.assetSheet.layouts.length; i++) {
                         if (this.assetSheet.layouts[i].name === name) {
                              return this.assetSheet.layouts[i];
                         }
                    }
                    return null;
               }

               preloadImage = (imageNode) => {

                    if (!imageNode.path) return;

                    // Create a new image object
                    var img = new Image();
                    img.src = imageNode.path;

                    // When the image is loaded, draw it onto the canvas
                    img.onload = () => {

                         // Create a new canvas object
                         var sourceCanvas = document.createElement('canvas');
                         var sourceContext = sourceCanvas.getContext('2d');

                         sourceCanvas.width = img.width;
                         sourceCanvas.height = img.height;

                         // If no clipPath is defined, draw the entire image onto the canvas
                         sourceContext.drawImage(img, 0, 0, img.width, img.height);

                         if (imageNode.clipPaths && imageNode.clipPaths.length > 0) {

                              imageNode.clipPaths.forEach((cpNode) => {

                                   // Calculate the bounding box of the clip path
                                   var xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity;
                                   for (var i = 0; i < cpNode.clipPath.length; i++) {
                                        xMin = Math.min(xMin, cpNode.clipPath[i].x);
                                        xMax = Math.max(xMax, cpNode.clipPath[i].x);
                                        yMin = Math.min(yMin, cpNode.clipPath[i].y);
                                        yMax = Math.max(yMax, cpNode.clipPath[i].y);
                                   }

                                   // Create a new canvas object
                                   var canvas = document.createElement('canvas');

                                   // Set the dimensions of the canvas based on the bounding box of the clip path
                                   canvas.width = xMax - xMin;
                                   canvas.height = yMax - yMin;

                                   var ctx = canvas.getContext('2d');

                                   sourceContext.strokeStyle = "red";
                                   sourceContext.lineWidth = 5;

                                   // Begin a new path and move to the first point in the clip path
                                   sourceContext.beginPath();
                                   sourceContext.moveTo(cpNode.clipPath[0].x, cpNode.clipPath[0].y);

                                   // Draw lines to the remaining points in the clip path
                                   for (var i = 1; i < cpNode.clipPath.length; i++) {
                                        sourceContext.lineTo(cpNode.clipPath[i].x, cpNode.clipPath[i].y);
                                   }

                                   // Close the path
                                   sourceContext.closePath();

                                   // Clip the canvas to the path
                                   sourceContext.clip();

                                   // Draw the image onto the canvas, offset by the top-left corner of the clip path
                                   ctx.drawImage(sourceCanvas, -xMin, -yMin);

                                   cpNode.Image = img;
                                   cpNode.Canvas = canvas;
                                   cpNode.CanvasContext = ctx;

                                   //if this is named, it means we may want to directly reference it
                                   if (cpNode.name) {
                                        this.assetSheet.images.push(cpNode);
                                   }

                              });

                              this.assetSheet.loops.push(imageNode);

                         } else {

                              imageNode.Image = img;

                              imageNode.Canvas = sourceCanvas;

                              imageNode.CanvasContext = sourceContext;

                              this.assetSheet.images.push(imageNode);

                         }

                    };

               }

          }

          const Ext = new Extension();

          return { Ext }
     })();

     // Public API
     global.$1S.Assets = {
          getAudio: OneSparkJs.Assets.Ext.getAudio,
          getImage: OneSparkJs.Assets.Ext.getImage,
          getSpriteLoop: OneSparkJs.Assets.Ext.getSpriteLoop,
          getTileset: OneSparkJs.Assets.Ext.getTileset
     };

})(typeof window !== 'undefined' ? window : global);

((global) => {

     const OneSparkJs = {};

     OneSparkJs.InputEventTypes = {
          KEY_DOWN: 'keydown',
          KEY_UP: 'keyup',
          MOUSE_MOVE: 'mousemove',
          MOUSE_UP: 'mouseup',
          MOUSE_CLICK: 'mouseclick',
          MOUSE_CLICK_OUT: 'mouseclickout',
          MOUSE_DOUBLE_CLICK: 'mousedoubleclick',
          RIGHT_MOUSE_CLICK: 'rightmouseclick',
          CENTER_MOUSE_CLICK: 'centermouseclick',
          RIGHT_MOUSE_UP: 'rightmouseup',
          CENTER_MOUSE_UP: 'centermouseup',
          MOUSE_SCROLL_UP: 'mousescrollup',
          MOUSE_SCROLL_DOWN: 'mousescrolldown',
          MOUSE_ENTER: 'mouseenter',
          MOUSE_LEAVE: 'mouseleave',
          MOUSE_CANVAS_ENTER: 'mousecanvasenter',
          MOUSE_CANVAS_LEAVE: 'mousecanvasleave',
          TOUCH_START: 'touchstart',
          TOUCH_MOVE: 'touchmove',
          TOUCH_END: 'touchend',
          TOUCH_CANCEL: 'touchcancel',
          SWIP_LEFT: 'swipeleft',
          SWIPE_RIGHT: 'swiperight',
          TAP: 'tap',
          TAP_OUT: 'tapout',
          DOUBLE_TAP: 'tap',
          PINCH: 'pinch',
          EXPAND: 'expand',
          ROTATE: 'rotate',
          SHAKE: 'shake',
          DEVICE_ORIENTATION: 'deviceorientation',
          DEVICE_MOTION: 'devicemotion',
          VISIBILITY_CHANGE: 'visibilitychange'
     };

     // IO module
     OneSparkJs.IO = (() => {
          const loadJSON = (path, callback) => {
               const xhr = new XMLHttpRequest();
               xhr.overrideMimeType('application/json');
               xhr.open('GET', path, true);
               xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4 && xhr.status === 200) {
                         callback(JSON.parse(xhr.responseText));
                    }
               };
               xhr.send(null);
          };

          return {
               loadJSON
          }
     })();

     //Audio module
     OneSparkJs.Inputs = (() => {

          class Extension extends $1S.Application.ExtensionType {

               //swipe
               swipeStartX = null;
               swipeStartT = null;
               swipeThreshold = 50; // Minimum distance in pixels to be considered a swipe

               //pinch, expand, rotate
               initialDistance = null;
               initialAngle = null;
               pinchThreshold = 10; // Minimum distance change in pixels to be considered a pinch or expand gesture

               //shake
               shakeHandlers = [];
               lastShakeTime = 0;
               shakeThreshold = 15; // Adjust this value to make the shake detection more or less sensitive
               shakeTimeout = 1000; // Time in milliseconds to wait before allowing another shake event

               tapTimeout = null;
               doubleTapTimeout = null;
               doubleTapThreshold = 300; // Maximum time in milliseconds between two taps to be considered a double tap
               tapThreshold = 200; // Maximum time in milliseconds between touchstart and touchend to be considered a tap

               handles = {};

               constructor() {
                    super(0);
               }

               onLoad = (appPath, properties, oncomplete) => {
                    if (properties.canvas) {
                         const canvas = document.getElementById(properties.canvas);

                         canvas.addEventListener(OneSparkJs.InputEventTypes.MOUSE_MOVE, this.mouseMoveEvent);
                         canvas.addEventListener("mousedown", this.mouseDownEvent);
                         canvas.addEventListener(OneSparkJs.InputEventTypes.MOUSE_UP, this.mouseUpEvent);
                         canvas.addEventListener("wheel", this.mouseScrollEvent);
                         canvas.addEventListener("mouseenter", this.mouseCanvasEnterEvent);
                         canvas.addEventListener("mouseleave", this.mouseCanvasLeaveEvent);
                         canvas.addEventListener(OneSparkJs.InputEventTypes.TOUCH_START, this.touchStartEvent);
                         canvas.addEventListener(OneSparkJs.InputEventTypes.TOUCH_MOVE, this.touchMoveEvent);
                         canvas.addEventListener(OneSparkJs.InputEventTypes.TOUCH_END, this.touchEndEvent);
                         canvas.addEventListener(OneSparkJs.InputEventTypes.TOUCH_CANCEL, this.touchCancelEvent);
                    }
                    window.addEventListener(OneSparkJs.InputEventTypes.KEY_DOWN, this.keyDownEvent);
                    window.addEventListener(OneSparkJs.InputEventTypes.KEY_UP, this.keyUpEvent);
                    window.addEventListener(OneSparkJs.InputEventTypes.DEVICE_ORIENTATION, this.deviceOrientationEvent);
                    window.addEventListener(OneSparkJs.InputEventTypes.DEVICE_MOTION, this.deviceMotionEvent);
                    document.addEventListener(OneSparkJs.InputEventTypes.VISIBILITY_CHANGE, this.visibilityChangeEvent);

                    oncomplete();
               }

               keyUpEvent = (event) => {
                    if (!this.handles[OneSparkJs.InputEventTypes.KEY_UP]) return;

                    // Sort the event this.handles by priority
                    this.handles[OneSparkJs.InputEventTypes.KEY_UP].sort((a, b) => a.priority - b.priority);

                    for (let i = 0; i < this.handles[OneSparkJs.InputEventTypes.KEY_UP].length; i++) {
                         const handle = this.handles[OneSparkJs.InputEventTypes.KEY_UP][i];

                         // Call the event handle with the event object as a parameter
                         const stopPropagation = handle.eventHandler(event);
                         if (stopPropagation) break;
                    }
               };

               keyDownEvent = (event) => {
                    if (!this.handles[OneSparkJs.InputEventTypes.KEY_DOWN]) return;

                    // Sort the event this.handles by priority
                    this.handles[OneSparkJs.InputEventTypes.KEY_DOWN].sort((a, b) => a.priority - b.priority);

                    for (let i = 0; i < this.handles[OneSparkJs.InputEventTypes.KEY_DOWN].length; i++) {
                         const handle = this.handles[OneSparkJs.InputEventTypes.KEY_DOWN][i];

                         // Call the event handle with the event object as a parameter
                         const stopPropagation = handle.eventHandler(event);
                         if (stopPropagation) break;
                    }
               };

               mouseMoveEvent = (event) => {
                    this.handleMouseEvent(event, OneSparkJs.InputEventTypes.MOUSE_MOVE);
               };

               mouseUpEvent = (event) => {
                    switch (event.button) {
                         case 0:
                              this.handleMouseEvent(event, OneSparkJs.InputEventTypes.MOUSE_UP);
                              break;
                         case 1:
                              this.handleMouseEvent(event, OneSparkJs.InputEventTypes.CENTER_MOUSE_UP);
                              break;
                         case 2:
                              this.handleMouseEvent(event, OneSparkJs.InputEventTypes.RIGHT_MOUSE_UP);
                              break;
                    }
               };

               mouseDownEvent = (event) => {
                    switch (event.button) {
                         case 0:
                              this.handleMouseEvent(event, OneSparkJs.InputEventTypes.MOUSE_CLICK);
                              break;
                         case 1:
                              this.handleMouseEvent(event, OneSparkJs.InputEventTypes.CENTER_MOUSE_CLICK);
                              break;
                         case 2:
                              this.handleMouseEvent(event, OneSparkJs.InputEventTypes.RIGHT_MOUSE_CLICK);
                              break;
                    }
               };

               mouseCanvasEnterEvent = (event) => {
                    this.handleGenericEvent(event, OneSparkJs.InputEventTypes.MOUSE_CANVAS_ENTER);
               };

               mouseCanvasLeaveEvent = (event) => {
                    this.handleGenericEvent(event, OneSparkJs.InputEventTypes.MOUSE_CANVAS_LEAVE);
               };

               mouseScrollEvent = (event) => {
                    if (event.deltaY > 0) {
                         this.handleMouseEvent(event, OneSparkJs.InputEventTypes.MOUSE_SCROLL_DOWN);
                    } else {
                         this.handleMouseEvent(event, OneSparkJs.InputEventTypes.MOUSE_SCROLL_UP);
                    }
               };

               touchStartEvent = (event) => {
                    if (event.touches.length === 1) {
                         this.swipeStartX = event.touches[0].clientX;
                         this.swipeStartT = event.touches[0].clientY;
                    } else if (event.touches.length === 2) {
                         this.initialDistance = calculateDistance(event.touches[0], event.touches[1]);
                         this.this.initialAngle = calculateAngle(event.touches[0], event.touches[1]);
                    }
                    this.handleTouchEvent(event, OneSparkJs.InputEventTypes.TOUCH_START);
               };

               touchMoveEvent = (event) => {
                    if (event.touches.length === 2) {
                         if (this.initialDistance !== null) {
                              const currentDistance = calculateDistance(event.touches[0], event.touches[1]);
                              if (Math.abs(currentDistance - this.initialDistance) > this.pinchThreshold) {
                                   if (currentDistance > this.initialDistance) {
                                        this.handlePinchEvent(event, OneSparkJs.InputEventTypes.EXPAND);
                                   } else {
                                        this.handlePinchEvent(event, OneSparkJs.InputEventTypes.PINCH);
                                   }
                                   this.initialDistance = currentDistance;
                              }
                         }

                         if (this.initialAngle !== null) {
                              const currentAngle = calculateAngle(event.touches[0], event.touches[1]);
                              const angleDifference = currentAngle - this.initialAngle;

                              this.handleRotationEvent(event, OneSparkJs.InputEventTypes.ROTATE, angleDifference);

                              this.initialAngle = currentAngle;
                         }
                    }
                    this.handleTouchEvent(event, OneSparkJs.InputEventTypes.TOUCH_MOVE);
               };

               touchEndEvent = (event) => {
                    if (event.touches.length === 0 && this.initialDistance === null && this.initialAngle === null) {
                         if (this.doubleTapTimeout !== null) {
                              clearTimeout(this.doubleTapTimeout);
                              this.doubleTapTimeout = null;
                              this.handleTapEvent(event, OneSparkJs.InputEventTypes.DOUBLE_TAP);
                         } else {
                              this.tapTimeout = setTimeout(() => {
                                   this.handleTapEvent(event, OneSparkJs.InputEventTypes.TAP);
                                   this.doubleTapTimeout = setTimeout(() => {
                                        this.doubleTapTimeout = null;
                                   }, this.doubleTapThreshold);
                              }, this.tapThreshold);
                         }
                    }

                    if (this.swipeStartX !== null && this.swipeStartT !== null) {
                         const touch = event.changedTouches[0];
                         const diffX = touch.clientX - this.swipeStartX;
                         const diffY = touch.clientY - this.swipeStartT;

                         if (Math.abs(diffX) > Math.abs(diffY)) {
                              if (Math.abs(diffX) > this.this.swipeThreshold) {
                                   if (diffX > 0) {
                                        this.handleSwipeEvent(event, OneSparkJs.InputEventTypes.SWIP_RIGHT);
                                   } else {
                                        this.handleSwipeEvent(event, OneSparkJs.InputEventTypes.SWIP_LEFT);
                                   }
                              }
                         }
                    }
                    this.swipeStartX = null;
                    this.swipeStartT = null;
                    this.initialDistance = null;
                    this.initialAngle = null;

                    this.handleTouchEvent(event, OneSparkJs.InputEventTypes.TOUCH_END);
               };

               touchCancelEvent = (event) => {
                    this.handleTouchEvent(event, OneSparkJs.InputEventTypes.TOUCH_CANCEL);
               };

               deviceOrientationEvent = (event) => {
                    this.handleDeviceEvent(event, OneSparkJs.InputEventTypes.DEVICE_ORIENTATION);
               };

               deviceMotionEvent = (event) => {
                    this.handleDeviceEvent(event, OneSparkJs.InputEventTypes.DEVICE_MOTION);

                    if (!event.accelerationIncludingGravity) return;

                    const { x, y, z } = event.accelerationIncludingGravity;
                    const accelerationMagnitude = Math.sqrt(x * x + y * y + z * z);

                    if (accelerationMagnitude > this.shakeThreshold && Date.now() - this.lastShakeTime > this.shakeTimeout) {
                         this.lastShakeTime = Date.now();
                         this.handleShakeEvent();
                    }
               };

               visibilityChangeEvent = () => {
                    const hidden = document.hidden;
                    this.handleVisibilityChange(hidden);
               };

               handleGenericEvent = (event, eventType) => {

                    if (!this.handles[eventType]) return;

                    // Sort the event this.handles by priority
                    this.handles[eventType].sort((a, b) => a.priority - b.priority);

                    for (let i = 0; i < this.handles[eventType].length; i++) {
                         const handle = this.handles[eventType][i];

                         // Call the event handle with the event object as a parameter
                         const stopPropagation = handle.eventHandler(event);
                         if (stopPropagation) break;
                    }
               };

               handleMouseEvent = (event, eventType) => {

                    if (!this.handles[eventType]) return;

                    // Sort the event this.handles by priority
                    this.handles[eventType].sort((a, b) => a.priority - b.priority);

                    for (let i = 0; i < this.handles[eventType].length; i++) {

                         const handle = this.handles[eventType][i];

                         // If the handle has specified a region, check if the event is inside the region
                         if (handle.region) {
                              if (
                                   event.clientX < handle.region.x1 ||
                                   event.clientX > handle.region.x2 ||
                                   event.clientY < handle.region.y1 ||
                                   event.clientY > handle.region.y2
                              ) {
                                   if (eventType == OneSparkJs.InputEventTypes.MOUSE_MOVE && (handle.isOver)) {
                                        handle.isOver = false;
                                        this.handleGenericEvent(event, OneSparkJs.InputEventTypes.MOUSE_LEAVE);
                                   }

                                   if (eventType == OneSparkJs.InputEventTypes.MOUSE_CLICK) {
                                        handle.isOver = false;
                                        this.handleGenericEvent(event, OneSparkJs.InputEventTypes.MOUSE_CLICK_OUT);
                                   }

                                   continue;
                              }
                         }

                         if (eventType == OneSparkJs.InputEventTypes.MOUSE_MOVE && (!handle.isOver)) {
                              handle.isOver = true;
                              this.handleGenericEvent(event, OneSparkJs.InputEventTypes.MOUSE_ENTER);
                         }

                         // Call the event handle with the event object as a parameter
                         const stopPropagation = handle.eventHandler(event);
                         if (stopPropagation) break;
                    }
               };

               handleTouchEvent = (event, eventType) => {
                    if (!this.handles[eventType]) return;

                    // Sort the event this.handles by priority
                    this.handles[eventType].sort((a, b) => a.priority - b.priority);

                    for (let i = 0; i < this.handles[eventType].length; i++) {
                         const handle = this.handles[eventType][i];

                         // Check if any of the touch points are inside the region
                         let insideRegion = false;
                         for (let j = 0; j < event.touches.length; j++) {
                              const touch = event.touches[j];
                              if (
                                   touch.clientX >= handle.region.x1 &&
                                   touch.clientX <= handle.region.x2 &&
                                   touch.clientY >= handle.region.y1 &&
                                   touch.clientY <= handle.region.y2
                              ) {
                                   insideRegion = true;
                                   break;
                              }
                         }

                         // If none of the touch points are inside the region, skip this handle
                         if (!insideRegion) continue;

                         // Call the event handle with the event object as a parameter
                         const stopPropagation = handle.eventHandler(event);
                         if (stopPropagation) break;
                    }

               };

               handleTapEvent = (event, eventType) => {
                    if (!this.handles[eventType]) return;

                    this.handles[eventType].sort((a, b) => a.priority - b.priority);

                    for (let i = 0; i < this.handles[eventType].length; i++) {
                         const handle = this.handles[eventType][i];

                         if (handle.region) {
                              if (
                                   event.clientX < handle.region.x1 ||
                                   event.clientX > handle.region.x2 ||
                                   event.clientY < handle.region.y1 ||
                                   event.clientY > handle.region.y2
                              ) {
                                   if (eventType == OneSparkJs.InputEventTypes.TAP) {
                                        handle.isOver = false;
                                        this.handleGenericEvent(event, OneSparkJs.InputEventTypes.TAP_OUT);
                                   }

                                   continue;
                              }
                         }

                         const stopPropagation = handle.eventHandler(event);
                         if (stopPropagation) break;
                    }
               };

               handleSwipeEvent = (event, eventType) => {
                    if (!this.handles[eventType]) return;

                    this.handles[eventType].sort((a, b) => a.priority - b.priority);

                    for (let i = 0; i < this.handles[eventType].length; i++) {
                         const handle = this.handles[eventType][i];

                         if (handle.region) {
                              if (
                                   event.clientX < handle.region.x1 ||
                                   event.clientX > handle.region.x2 ||
                                   event.clientY < handle.region.y1 ||
                                   event.clientY > handle.region.y2
                              ) {
                                   continue;
                              }
                         }

                         const stopPropagation = handle.eventHandler(event);
                         if (stopPropagation) break;
                    }
               };

               handlePinchEvent = (event, eventType) => {
                    if (!this.handles[eventType]) return;

                    this.handles[eventType].sort((a, b) => a.priority - b.priority);

                    for (let i = 0; i < this.handles[eventType].length; i++) {
                         const handle = this.handles[eventType][i];

                         if (handle.region) {
                              if (
                                   event.clientX < handle.region.x1 ||
                                   event.clientX > handle.region.x2 ||
                                   event.clientY < handle.region.y1 ||
                                   event.clientY > handle.region.y2
                              ) {
                                   continue;
                              }
                         }

                         const stopPropagation = handle.eventHandler(event);
                         if (stopPropagation) break;
                    }
               };

               handleRotationEvent = (event, eventType, angleDifference) => {
                    if (!this.handles[eventType]) return;

                    this.handles[eventType].sort((a, b) => a.priority - b.priority);

                    for (let i = 0; i < this.handles[eventType].length; i++) {
                         const handle = this.handles[eventType][i];

                         if (handle.region) {
                              if (
                                   event.clientX < handle.region.x1 ||
                                   event.clientX > handle.region.x2 ||
                                   event.clientY < handle.region.y1 ||
                                   event.clientY > handle.region.y2
                              ) {
                                   continue;
                              }
                         }

                         const stopPropagation = handle.eventHandler(event, angleDifference);
                         if (stopPropagation) break;
                    }
               };

               handleDeviceEvent = (event, eventType) => {
                    if (!this.handles[eventType]) return;

                    this.handles[eventType].sort((a, b) => a.priority - b.priority);

                    for (let i = 0; i < this.handles[eventType].length; i++) {
                         const handle = this.handles[eventType][i];

                         const stopPropagation = handle.eventHandler(event);
                         if (stopPropagation) break;
                    }
               };

               handleShakeEvent = () => {
                    if (!this.handles[OneSparkJs.InputEventTypes.SHAKE]) return;

                    this.handles[OneSparkJs.InputEventTypes.SHAKE].sort((a, b) => a.priority - b.priority);

                    for (let i = 0; i < this.handles[OneSparkJs.InputEventTypes.SHAKE].length; i++) {
                         const handle = this.handles[OneSparkJs.InputEventTypes.SHAKE][i];

                         const stopPropagation = handle.eventHandler();
                         if (stopPropagation) break;
                    }
               };

               handleVisibilityChange = (hidden) => {
                    if (!this.handles[OneSparkJs.InputEventTypes.VISIBILITY_CHANGE]) return;

                    this.handles[OneSparkJs.InputEventTypes.VISIBILITY_CHANGE].sort((a, b) => a.priority - b.priority);

                    for (let i = 0; i < this.handles[OneSparkJs.InputEventTypes.VISIBILITY_CHANGE].length; i++) {
                         const handle = this.handles[OneSparkJs.InputEventTypes.VISIBILITY_CHANGE][i];

                         const stopPropagation = handle.eventHandler({ hidden });
                         if (stopPropagation) break;
                    }
               };

               attach = (eventType, source, eventHandler, priority = 100, region = null) => {
                    if (!this.handles[eventType]) this.handles[eventType] = [];

                    const h = {
                         source,
                         eventHandler,
                         priority: priority || 0,
                         isOver: false,
                         region
                    };

                    this.handles[eventType].push(h);

                    return h;
               };

               release = (source) => {
                    for (const eventType in this.handles) {
                         if (this.handles.hasOwnProperty(eventType)) {
                              this.handles[eventType] = this.handles[eventType].filter(
                                   (handle) => handle.source !== source
                              );
                         }
                    }
               };

               clear = (source) => {
                    this.handles = {};
               };

               calculateDistance = (touch1, touch2) => {
                    const diffX = touch2.clientX - touch1.clientX;
                    const diffY = touch2.clientY - touch1.clientY;
                    return Math.sqrt(diffX * diffX + diffY * diffY);
               };

               calculateAngle = (touch1, touch2) => {
                    const diffX = touch2.clientX - touch1.clientX;
                    const diffY = touch2.clientY - touch1.clientY;
                    return Math.atan2(diffY, diffX);
               };

          }

          const Ext = new Extension();

          return { Ext }
     })();

     // Public API
     global.$1S.IO = {
          Input: {
               EventType: OneSparkJs.InputEventTypes,
               attach: OneSparkJs.Inputs.Ext.attach,
               release: OneSparkJs.Inputs.Ext.release,
               clear: OneSparkJs.Inputs.Ext.clear
          },
          loadJSON: OneSparkJs.IO.loadJSON,
     };

})(typeof window !== 'undefined' ? window : global);

((global) => {

     const OneSparkJs = {};

     //Audio module
     OneSparkJs.Audio = (() => {

          class Extension extends $1S.Application.ExtensionType {

               audioCache = new Map();
               activeAudios = new Set();

               constructor() {
                    super(0);
               }

               onLoad = (appPath, properties, oncomplete) => {
                    //does nothing for now
                    oncomplete();
               }

               playAudio = (name, loop = false, volume = 1) => {

                    const node = $1S.Assets.getAudio(name);
                    if (node == null) return;
                    const src = node.path;

                    const audioElement = this.getAudioElement(src);

                    if (this.activeAudios.has(audioElement)) {
                         // If the audio element is already active, restart it from the beginning
                         audioElement.currentTime = 0;
                    } else {
                         // Otherwise, add the audio element to the set of active audios
                         this.activeAudios.add(audioElement);
                    }

                    // Set the loop property if necessary
                    if (loop) {
                         audioElement.loop = true;
                    }

                    // Set the volume if necessary
                    if (volume !== 1) {
                         audioElement.volume = volume;
                    }

                    // Play the audio file
                    audioElement.play();
               };

               stopAudio = (name) => {

                    const node = $1S.Assets.getAudio(name);
                    if (node == null) return;
                    const src = node.path;

                    const audioElement = this.audioCache.get(src);
                    if (audioElement && this.activeAudios.has(audioElement)) {
                         audioElement.pause();
                         audioElement.currentTime = 0;
                         this.activeAudios.delete(audioElement);
                    }
               }

               stopAllAudios = () => {
                    this.activeAudios.forEach((audioElement) => {
                         audioElement.pause();
                         audioElement.currentTime = 0;
                         this.activeAudios.delete(audioElement);
                    });
               }

               preloadAudio = (src) => {
                    this.getAudioElement(src);
               }

               getAudioElement = (src) => {
                    if (this.audioCache.has(src)) {
                         return this.audioCache.get(src);
                    } else {
                         const audioElement = new Audio(src);
                         this.audioCache.set(src, audioElement);
                         return audioElement;
                    }
               }
          }

          const Ext = new Extension();

          return { Ext }
     })();

     // Public API
     global.$1S.Audio = {
          preload: OneSparkJs.Audio.Ext.preloadAudio,
          play: OneSparkJs.Audio.Ext.playAudio,
          stop: OneSparkJs.Audio.Ext.stopAudio,
          stopAll: OneSparkJs.Audio.Ext.stopAllAudios
     };

})(typeof window !== 'undefined' ? window : global);

((global) => {

     const OneSparkJs = {};

     //Rederer module
     OneSparkJs.Renderer = (() => {

          class Vertex {
               constructor(x = 0, y = 0, z = 0) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
               }
          }

          //Renderable types
          const SortByEnum = {
               byPriority: 0,
               byDepth: 1
          };

          const SortByTypes = {
               byPriority: {
                    sortOnRegister: true,
                    sortOnRender: false,
                    compare: function (a, b) {
                         return a.Priority - b.Priority;
                    }
               },
               byDepth: {
                    sortOnRegister: true,
                    sortOnRender: true,
                    compare: function (a, b) {
                         return a.instance.orientation.z - b.instance.orientation.z;
                    }
               }
          };

          class RenderableType {

               constructor(properties = {}) {
                    this.id = $1S.Helper.newId();
                    this.stageProps = [];  //sub props
                    this.isActive = properties.isActive || true;


                    if (this.sortBy)
                         this.setRenderSort(this.sortBy);
                    else
                         this.setRenderSort(SortByEnum.byPriority);
               }

               setRenderSort = (sortByEnum) => {

                    if (sortByEnum == SortByEnum.byPriority) {
                         this.sortBy = OneSparkJs.Renderer.SortByTypes.byPriority;
                    }
                    if (sortByEnum == SortByEnum.byDepth) {
                         this.sortBy = OneSparkJs.Renderer.SortByTypes.byDepth;
                    }
               }

               registerProp = (instance, properties = {}, priority = 100000) => {

                    if ((!(instance instanceof OneSparkJs.Renderer2D.StagePropType)) && !(instance instanceof OneSparkJs.Renderer2DTransform.TransformType))
                         throw new Error("Not a StagePropType or TransformType component.");

                    const newRegistration = {
                         instance: instance,
                         Properties: properties,
                         Priority: priority
                    };

                    this.stageProps.push(newRegistration);

                    if (this.sortBy.sortOnRegister) {
                         this.stageProps.sort(this.sortBy.compare);
                    }

                    return this.registerProp;
               }

               getProp = (id) => {

                    const subPropsObj = this.stageProps.find(prop => prop.instance.id === id);

                    if (subPropsObj) {
                         return subPropsObj.instance;
                    }

                    return null;
               }

               destroyProp = (id) => {

                    const index = this.stageProps.findIndex(prop => prop.instance.id === id);

                    if (index !== -1) {
                         if (this.stageProps[index].onDestroy)
                              this.stageProps[index].onDestroy();

                         this.stageProps.splice(index, 1);
                         return true;
                    }

                    return false;
               }

               clearProps = () => {
                    for (var i = 0; i < this.stageProps.length; i++)
                         if (this.stageProps[i].onDestroy)
                              this.stageProps[i].onDestroy();

                    this.stageProps[i] = [];
               }

               raiseTickEvent (timeStamp, deltaTime) {

                    if (!this.isActive) return;

                    if (this.onTick)
                         this.onTick(timeStamp, deltaTime);

                    for (var i = 0; i < this.stageProps.length; i++)
                         this.stageProps[i].instance.raiseTickEvent(timeStamp, deltaTime);

               }

               raiseRenderEvent(context) {

                    if (!this.isActive) return;

                    if (this.onDraw)
                         this.onDraw(context);

                    if (this.stageProps.length > 0) {
                         if (this.sortBy.sortOnRender) {
                              this.stageProps.sort(this.sortBy.compare);
                         }

                         for (var i = 0; i < this.stageProps.length; i++)
                              if (this.stageProps[i].instance.raiseRenderEvent)
                                   this.stageProps[i].instance.raiseRenderEvent(context);
                    }


                    if (this.onPostDraw)
                         this.onPostDraw(context);
               }

               raiseResizeEvent(w, h) {
                    if (this.onResize)
                         this.onResize(w, h);

                    for (var i = 0; i < this.stageProps.length; i++)
                         this.stageProps[i].instance.raiseResizeEvent(this.width, this.height);
               }

               raiseDisposeEvent() {
                    if (this.stageProps.length > 0) {
                         for (var i = 0; i < this.stageProps.length; i++)
                              if (this.stageProps[i].instance.raiseDisposeEvent)
                                   this.stageProps[i].instance.raiseDisposeEvent();
                    }
                    if (this.onDispose)
                         this.onDispose();
               }

               raiseShowStageEvent() {

                    if (!this.isActive) return;

                    if (this.stageProps.length > 0) {
                         for (var i = 0; i < this.stageProps.length; i++) {
                              if (this.stageProps[i].instance.raiseShowStageEvent)
                                   this.stageProps[i].instance.raiseShowStageEvent();

                         }
                    }
                    if (this.onShowStage)
                         this.onShowStage();
               }

               raiseHideStageEvent() {

                    if (!this.isActive) return;

                    if (this.stageProps.length > 0) {
                         for (var i = 0; i < this.stageProps.length; i++)
                              if (this.stageProps[i].instance.raiseHideStageEvent)
                                   this.stageProps[i].instance.raiseHideStageEvent();
                    }
                    if (this.onHideStage)
                         this.onHideStage();
               }

          }

          class StageType extends RenderableType {
               constructor(name, properties = {}) {
                    super();

                    const size = $1S.Renderer.Canvas.getSize();
                    this.width = size.width;
                    this.height = size.height;

                    this.name = name;
                    $1S.Renderer.register(name, this);

                    if (this.onInit) this.onInit(properties);
               }

               raiseRenderEvent = (context) => {
                    if (!this.isActive) return;

                    context.clearRect(0, 0, this.width, this.height);

                    super.raiseRenderEvent(context);

                    $1S.Renderer.Canvas.publish();
               }

               raiseResizeEvent(w, h) {
                    this.width = w;
                    this.height = h;

                    super.raiseResizeEvent(w, h);
               }

          }

          class Extension extends $1S.Application.ExtensionType {

               stages = {};
               activeStageName = null;

               constructor() {
                    super(0);
               }

               onLoad = (appPath, properties, oncomplete) => {
                    if (properties.canvas) {
                         OneSparkJs.Canvas.initialize(properties.canvas, properties.fullWindow);
                    }
                    oncomplete();
               }

               getActiveName = () => {
                    return this.activeStageName;
               }

               register = (name, instance = null) => {
                    if (!name)
                         throw new Error("Invalid stage name.");

                    if (this.stages[name])
                         throw new Error("Stage already defined.");

                    if (instance == null || !(instance instanceof StageType))
                         throw new Error("Not a StageType.");

                    this.stages[name] = {
                         Name: name,
                         instance: instance,
                         SavedState: null
                    };
               }

               raiseResizeEvent = (w,h) => {
                    if (this.activeStageName == null) return;

                    const stage = this.stages[this.activeStageName];

                    if (!stage) return;

                    stage.instance.raiseResizeEvent(w, h);
               }

               raiseRenderEvent = () => {

                    if (this.activeStageName == null) return;

                    const stage = this.stages[this.activeStageName];

                    if (!stage) return;

                    const context = $1S.Renderer.Canvas.getContext();

                    stage.instance.raiseRenderEvent(context);
               }

               get = () => {
                    var stage = null;

                    if (this.activeStageName != null) {
                         stage = this.stages[this.activeStageName];
                    }

                    return stage;
               }

               destroy = (stageName = null) => {
                    stageName = stageName || this.activeStageName;

                    if (this.activeStageName === stageName) {
                         this.stages[this.activeStageName].raiseHideStageEvent();
                         this.activeStageName = null;
                    }

                    const stage = this.stages[stageName];

                    if (!stage) {
                         throw new Error("Stage not found.");
                    }

                    stage.raiseDisposeEvent();

                    stage.clearProps();

                    delete this.stages[stageName];
               }

               switchTo = (name) => {

                    if (this.activeStageName != null) {
                         this.stages[this.activeStageName].instance.raiseHideStageEvent();
                         this.stages[this.activeStageName].SavedState = $1S.Renderer.Canvas.getState();
                    }

                    if (name == null) {
                         this.activeStageName = null;
                         return;
                    }

                    if (!this.stages[name]) {
                         throw new Error(`Stage not found: ${name}`);
                    }

                    this.activeStageName = name;
                    if (this.stages[this.activeStageName].SavedState != null) {
                         if (this.stages[this.activeStageName].SavedState)
                              $1S.Renderer.Canvas.setState(this.stages[this.activeStageName].SavedState);
                    }

                    this.stages[this.activeStageName].instance.raiseShowStageEvent();

               }

               handleTickEvent = (timeStamp, deltaTime) => {
                    if (this.activeStageName) {
                         const stage = this.stages[this.activeStageName];
                         stage.instance.raiseTickEvent(timeStamp, deltaTime);
                    }
               }

               handlePostTickEvent = (timeStamp, deltaTime) => {
                    this.raiseRenderEvent();
               }

               reset = () => {

                    const stageNames = Object.keys(this.stages);

                    for (var i = 0; i < this.stagesNames.length; i++) {
                         destroy(stageNames[i]);
                    }
                    this.stages = {};
                    this.activeStageName = null;
               }

          }

          const Ext = new Extension();

          return { Vertex, RenderableType, SortByEnum, SortByTypes, StageType, Ext }
     })();

     //Rederer module
     OneSparkJs.Renderer2D = (() => {

          //stage prop types
          const AlignOnEnum = {
               Center: 0,     //drawn on parent using center coordinate
               UpperLeft: 1,  //drawn on parent using upper left coordinate (0,0)
               UpperRight: 2, //drawn on parent using upper right coordinate
               LowerLeft: 3,  //drawn on parent using lower left coordinate
               LowerRight: 4  //drawn on parent using lower right coordinate
          };

          class Orientation extends OneSparkJs.Renderer.Vertex {
               constructor(x = 0, y = 0, z = 0, alignment = AlignOnEnum.Center, xScale = 1, yScale = 1, rotation = 0) {
                    super(x, y, z);
                    this.rotation = rotation;
                    this.xScale = xScale;
                    this.yScale = yScale;
                    this.scaleToContainer = false;
                    this.alignment = alignment;
               }

               get alignment() {
                    return this._alignment;
               }

               set alignment(value) {
                    if (Object.values(AlignOnEnum).indexOf(value) === -1) {
                         throw new Error('Invalid alignment value');
                    }
                    this._alignment = value;
               }
          }

          class StagePropType extends OneSparkJs.Renderer.RenderableType {

               constructor(properties = {}, skipInit = false) {
                    super();

                    this.orientation = new Orientation(
                         properties.x || 0,
                         properties.y || 0,
                         properties.z || 0,
                         properties.alignment || AlignOnEnum.Center,
                         properties.xScale || 1,
                         properties.yScale || 1,
                         properties.rotation || 0
                    );

                    this.width = properties.width || 100;
                    this.height = properties.height || 100;
                    this.isVisible = properties.isVisible || true;

                    //get screen size
                    const size = $1S.Renderer.Canvas.getSize();
                    this.screenWidth = size.width;
                    this.screenHeight = size.height;

                    this.workCanvas = document.createElement('canvas');
                    this.workCanvas.width = this.width;
                    this.workCanvas.height = this.height;
                    this.workContext = this.workCanvas.getContext('2d');

                    if ((!skipInit) && this.onInit) this.onInit(properties);
               }

               getRegion() {
                    const xScale = this.orientation.xScale;
                    const yScale = this.orientation.yScale;

                    switch (this.orientation.alignment) {
                         case AlignOnEnum.Center:
                              return {
                                   x1: this.orientation.x - this.width * xScale / 2,
                                   y1: this.orientation.y - this.height * yScale / 2,
                                   x2: this.orientation.x + this.width * xScale / 2,
                                   y2: this.orientation.y + this.height * yScale / 2
                              };

                         case AlignOnEnum.UpperLeft:
                              return {
                                   x1: this.orientation.x,
                                   y1: this.orientation.y,
                                   x2: this.orientation.x + this.width * xScale,
                                   y2: this.orientation.y + this.height * yScale
                              };

                         case AlignOnEnum.UpperRight:
                              return {
                                   x1: this.orientation.x - this.width * xScale,
                                   y1: this.orientation.y,
                                   x2: this.orientation.x,
                                   y2: this.orientation.y + this.height * yScale
                              };

                         case AlignOnEnum.LowerLeft:
                              return {
                                   x1: this.orientation.x,
                                   y1: this.orientation.y - this.height * yScale,
                                   x2: this.orientation.x + this.width * xScale,
                                   y2: this.orientation.y
                              };

                         case AlignOnEnum.LowerRight:
                              return {
                                   x1: this.orientation.x - this.width * xScale,
                                   y1: this.orientation.y - this.height * yScale,
                                   x2: this.orientation.x,
                                   y2: this.orientation.y
                              };

                         default:
                              return {
                                   x1: this.orientation.x,
                                   y1: this.orientation.y,
                                   x2: this.orientation.x + this.width * xScale,
                                   y2: this.orientation.y + this.height * yScale
                              };
                    }
               }

               setRegion(region) {

                    var regionWidth = Math.abs(region.x2 - region.x1);
                    var regionHeight = Math.abs(region.y2 - region.y1);

                    this.orientation.xScale = regionWidth / this.width;
                    this.orientation.yScale = regionHeight / this.height;

                    switch (this.orientation.alignment) {
                         case AlignOnEnum.Center:
                              this.orientation.x = region.x1 + ((region.x2 - region.x1) / 2);
                              this.orientation.y = region.y1 + ((region.y2 - region.y1) / 2);
                              break;
                         case AlignOnEnum.UpperLeft:
                              this.orientation.x = region.x1;
                              this.orientation.y = region.y1; 
                              break;
                         case AlignOnEnum.UpperRight:
                              this.orientation.x = region.x2;
                              this.orientation.y = region.y1;
                              break;
                         case AlignOnEnum.LowerLeft:
                              this.orientation.x = region.x1;
                              this.orientation.y = region.y2;
                              break;
                         case AlignOnEnum.LowerRight:
                              this.orientation.x = region.x2;
                              this.orientation.y = region.y2;
                              break;
                         default:
                              this.orientation.x = region.x1;
                              this.orientation.y = region.y1;
                              break;
                    }

               }

               show() {
                    this.isVisible = true;
               }

               hide() {
                    this.isVisible = false;
               }

               raiseRenderEvent = (context) => {

                    if (!this.isActive) return;

                    if (!this.isVisible) return;

                    if (this.onDraw)
                         this.onDraw(this.workContext);

                    super.raiseRenderEvent(this.workContext);

                    if (this.onPostDraw)
                         this.onPostDraw(this.workContext);

                    const scaledWidth = this.width * this.orientation.xScale;
                    const scaledHeight = this.height * this.orientation.yScale;

                    if (this.orientation.rotation != 0) {
                         const rotationAngle = (Math.PI / 180) * this.orientation.rotation;

                         switch (this.orientation.alignment) {
                              case AlignOnEnum.Center:
                                   context.save();
                                   context.translate(this.orientation.x, this.orientation.y);
                                   context.rotate(rotationAngle);
                                   context.scale(this.orientation.xScale, this.orientation.yScale);
                                   context.translate(-(scaledWidth / 2), -(scaledHeight / 2));
                                   context.drawImage(this.workCanvas, 0, 0, this.width, this.height, 0, 0, scaledWidth, scaledHeight);
                                   context.restore();
                                   break;
                              case AlignOnEnum.UpperLeft:
                                   context.save();
                                   context.translate(this.orientation.x, this.orientation.y);
                                   context.rotate(rotationAngle);
                                   context.scale(this.orientation.xScale, this.orientation.yScale);
                                   context.drawImage(this.workCanvas, 0, 0, this.width, this.height, 0, 0, scaledWidth, scaledHeight);
                                   context.restore();
                                   break;
                              case AlignOnEnum.UpperRight:
                                   context.save();
                                   context.translate(this.orientation.x, this.orientation.y);
                                   context.rotate(rotationAngle);
                                   context.scale(this.orientation.xScale, this.orientation.yScale);
                                   context.translate(-scaledWidth, 0);
                                   context.drawImage(this.workCanvas, 0, 0, this.width, this.height, 0, 0, scaledWidth, scaledHeight);
                                   context.restore();
                                   break;
                              case AlignOnEnum.LowerLeft:
                                   context.save();
                                   context.translate(this.orientation.x, this.orientation.y);
                                   context.rotate(rotationAngle);
                                   context.scale(this.orientation.xScale, this.orientation.yScale);
                                   context.translate(0, -scaledHeight);
                                   context.drawImage(this.workCanvas, 0, 0, this.width, this.height, 0, 0, scaledWidth, scaledHeight);
                                   context.restore();
                                   break;
                              case AlignOnEnum.LowerRight:
                                   context.save();
                                   context.translate(this.orientation.x, this.orientation.y);
                                   context.rotate(rotationAngle);
                                   context.scale(this.orientation.xScale, this.orientation.yScale);
                                   context.translate(-scaledWidth, -scaledHeight);
                                   context.drawImage(this.workCanvas, 0, 0, this.width, this.height, 0, 0, scaledWidth, scaledHeight);
                                   context.restore();
                                   break;
                              default:
                                   context.save();
                                   context.translate(this.orientation.x, this.orientation.y);
                                   context.rotate(rotationAngle);
                                   context.scale(this.orientation.xScale, this.orientation.yScale);
                                   context.translate(-(scaledWidth / 2), -(scaledHeight / 2));
                                   context.drawImage(this.workCanvas, 0, 0, this.width, this.height, 0, 0, scaledWidth, scaledHeight);
                                   context.restore();
                         }
                    } else {
                         switch (this.orientation.alignment) {
                              case AlignOnEnum.Center:
                                   context.drawImage(
                                        this.workCanvas,
                                        0,
                                        0,
                                        this.width,
                                        this.height,
                                        this.orientation.x - (scaledWidth / 2),
                                        this.orientation.y - (scaledHeight / 2),
                                        scaledWidth,
                                        scaledHeight
                                   );
                                   break;
                              case AlignOnEnum.UpperLeft:
                                   context.drawImage(
                                        this.workCanvas,
                                        0,
                                        0,
                                        this.width,
                                        this.height,
                                        this.orientation.x,
                                        this.orientation.y,
                                        scaledWidth,
                                        scaledHeight
                                   );
                                   break;
                              case AlignOnEnum.UpperRight:
                                   context.drawImage(
                                        this.workCanvas,
                                        0,
                                        0,
                                        this.width,
                                        this.height,
                                        this.orientation.x,
                                        this.orientation.y - scaledHeight,
                                        scaledWidth,
                                        scaledHeight
                                   );
                                   break;
                              case AlignOnEnum.LowerLeft:
                                   context.drawImage(
                                        this.workCanvas,
                                        0,
                                        0,
                                        this.width,
                                        this.height,
                                        this.orientation.x - scaledWidth,
                                        this.orientation.y,
                                        scaledWidth,
                                        scaledHeight
                                   );
                                   break;
                              case AlignOnEnum.LowerRight:
                                   context.drawImage(
                                        this.workCanvas,
                                        0,
                                        0,
                                        this.width,
                                        this.height,
                                        this.orientation.x - scaledWidth,
                                        this.orientation.y - scaledHeight,
                                        scaledWidth,
                                        scaledHeight
                                   );
                                   break;
                              default:
                                   context.drawImage(
                                        this.workCanvas,
                                        0,
                                        0,
                                        this.width,
                                        this.height,
                                        this.orientation.x - (scaledWidth / 2),
                                        this.orientation.y - (scaledHeight / 2),
                                        scaledWidth,
                                        scaledHeight
                                   );
                         }

                    }

               }

          }

          class SpritePropType extends StagePropType {

               constructor(properties = {}) {
                    super(properties);

                    this.activeLoop = null;
                    this.spriteLoop = {};

                    this.frame = properties.frameStart || 0;
                    this.framesPerSecond = properties.framesPerSecond || 12;
                    this.frameTime = 1000 / this.framesPerSecond;

                    this.sizeChange = false;

                    this.renderedFrame = -1;
                    this.lastFrameUpdateTime = 0;

                    if (properties.groupName)
                         this.loadGroup(properties.groupName);

                    if (properties.imageName)
                         this.loadImage(properties.imageName, 1);

               }

               onInit(properties) {
               }

               onTick(timeStamp, deltaTime) {
                    if (this.activeLoop && this.isVisible && this.activeLoop.clipPaths.length > 1) {
                         const timeSinceLastFrameUpdate = timeStamp - this.lastFrameUpdateTime;
                         if (timeSinceLastFrameUpdate >= this.frameTime) {
                              this.lastFrameUpdateTime = timeStamp;
                              this.frame++;
                              if (this.frame >= this.activeLoop.clipPaths.length) {
                                   this.frame = 0;
                              }
                         }
                    }
               }

               onDraw(context) {
                    if (this.activeLoop && this.isVisible && this.frame != this.renderedFrame) {
                         const groupCanvas = this.activeLoop.clipPaths[this.frame].Canvas;
                         this.activeLoop.clipPaths[this.frame].CanvasContext;

                         context.clearRect(0, 0, this.width, this.height);
                         context.drawImage(groupCanvas, 0, 0);

                         this.renderedFrame = this.frame;
                    }
               }

               loadGroup(loopName) {
                    if (!loopName)
                         throw new Error("A sprite group is required.")

                    const loop = $1S.Assets.getSpriteLoop(loopName);

                    if (!loop)
                         throw new Error(`Sprite group ${loopName} not found.`)

                    this.adjustCanvas(loop);

                    this.spriteLoop[loopName] = loop;

                    if (!this.activeLoop) {
                         this.activeLoop = loop;
                    }               }

               loadImage(imageName, frameCount) {
                    if (!imageName)
                         throw new Error("An image is required.")

                    const image = $1S.Assets.getImage(imageName);

                    if (!image)
                         throw new Error(`Sprite image ${imageName} not found.`)

                    const group = {
                         group: imageName,
                         clipPaths: []
                    };

                    for (var i = 0; i < frameCount; i++) {
                         group.clipPaths.push({
                              Canvas: image.Canvas,
                              CanvasContext: image.CanvasContext
                         });
                    }

                    this.adjustCanvas(group);

                    this.spriteLoop[imageName] = group;

                    if (!this.activeLoop) {
                         this.activeLoop = group;
                    }               }

               show(groupName) {

                    var group = this.spriteLoop[groupName];

                    if (!group) {
                         this.loadGroup(groupName);
                         group = this.spriteLoop[groupName];
                    }

                    this.frame = 0;
                    this.activeLoop = group;
               }

               adjustCanvas(group) {

                    var changeSize = false;

                    for (var i = 0; i < group.clipPaths.length; i++) {
                         if (this.width < group.clipPaths[i].Canvas.width) {
                              this.width = group.clipPaths[i].Canvas.width;
                              changeSize = true;
                         }

                         if (this.height < group.clipPaths[i].Canvas.height) {
                              this.height = group.clipPaths[i].Canvas.height;
                              changeSize = true;
                         }
                    }

                    if (changeSize) {
                         this.workCanvas.width = this.width;
                         this.workCanvas.height = this.height;
                         this.workContext = this.workCanvas.getContext('2d');
                    }

               }

          }

          class TilesetPropType extends StagePropType {

               constructor(layoutName, properties = {}) {
                    super(properties);

                    if (!layoutName)
                         throw new Error(`Layout name invalid.`)

                    this.layoutName = layoutName;

                    this.tiles = [];

                    this.initialize();
               }

               initialize() {
                    var layout = $1S.Assets.getTileset(this.layoutName);

                    if (!layout)
                         throw new Error(`Layout ${layoutName} not found.`)

                    for (var i = 0; i < layout.tiles.length; i++) {
                         const tile = layout.tiles[i];

                         const sprite = new SpritePropType(
                              {
                                   imageName: tile.imageName,
                                   groupName: tile.groupName,
                                   framesPerSecond: tile.frameRate || 0,
                                   framesStart: tile.frameStart || 0,
                                   x: tile.x || 0,
                                   y: tile.y || 0,
                                   alignOn: tile.alignOn || AlignOnEnum.UpperLeft
                              });

                         this.registerProp(sprite);

                    }
               }

          }

          return { AlignOnEnum, Orientation, StagePropType, SpritePropType, TilesetPropType }
     })();

     //Rederer module
     OneSparkJs.Renderer2DTransform = (() => {

          //prop transforms
          class TransformType {

               constructor(parent, child, properties) {
                    this.id = $1S.Helper.newId();

                    this.parent = parent;

                    this.child = child;
                    this.childRegion = this.child.getRegion();

                    if (this.onInit) this.onInit(properties);
               }

               raiseTickEvent(timeStamp, deltaTime) {

                    if (this.onTick)
                         this.onTick(timeStamp, deltaTime);

                    this.child.raiseTickEvent(timeStamp, deltaTime);
               }

               raiseRenderEvent(context) {

                    if (this.onDraw)
                         this.onDraw(context);

                    this.child.raiseRenderEvent(context);
               }

               raiseResizeEvent(w, h) {

                    if (this.onResize)
                         this.onResize(w, h);

                    this.child.raiseResizeEvent(w, h);
               }

               raiseDisposeEvent() {

                    if (this.onDispose)
                         this.onDispose(w, h);

                    this.child.raiseDisposeEvent();
               }

               raiseShowStageEvent() {

                    this.child.raiseShowStageEvent();
               }

               raiseHideStageEvent() {
                    this.child.raiseHideStageEvent();
               }

          }

          const AnchorTypeEnum = {
               None: 0,
               Absolute: 1,
               Relative: 2,
               Centered: 3
          };

          class AnchorTransformType extends TransformType {

               onInit(properties) {
                    this.anchorLeft = properties.anchorLeft || AnchorTypeEnum.None;
                    this.anchorLeftValue = properties.anchorLeftValue || 0;
                    this.anchorRight = properties.anchorRight || AnchorTypeEnum.None;
                    this.anchorRightValue = properties.anchorRightValue || 0;
                    this.anchorTop = properties.anchorTop || AnchorTypeEnum.None;
                    this.anchorTopValue = properties.anchorTopValue || 0;
                    this.anchorBottom = properties.anchorBottom || AnchorTypeEnum.None;
                    this.anchorBottomValue = properties.anchorBottomValue || 0;
                    this.keepAspectRatio = properties.keepAspectRatio || false;

                    this.updateRegion();
               }

               onResize() {
                    this.updateRegion();
               }

               updateRegion() {
                    var childWidth = this.child.width * this.child.orientation.xScale;
                    var childHeight = this.child.height * this.child.orientation.yScale;
                    const childRatio = childWidth / childHeight;

                    //left
                    if (this.anchorLeft == AnchorTypeEnum.Absolute) {
                         this.childRegion.x1 = this.anchorLeftValue;

                         if (this.anchorRight == AnchorTypeEnum.None)
                              this.childRegion.x2 = this.childRegion.x1 + childWidth;
                    }
                    else if (this.anchorLeft == AnchorTypeEnum.Relative) {
                         this.childRegion.x1 = this.parent.width * (this.anchorLeftValue / 100);

                         if (this.anchorRight == AnchorTypeEnum.None)
                              this.childRegion.x2 = this.childRegion.x1 + childWidth;
                    }
                    else if (this.anchorLeft == AnchorTypeEnum.Centered) {
                         this.childRegion.x1 = ((this.parent.width / 2) - (childWidth / 2)) - this.anchorLeftValue;

                         if (this.anchorRight == AnchorTypeEnum.None)
                              this.childRegion.x2 = this.childRegion.x1 + childWidth;
                    }

                    //right
                    if (this.anchorRight == AnchorTypeEnum.Absolute) {
                         this.childRegion.x2 = this.parent.width - this.anchorRightValue;

                         if (this.anchorLeft == AnchorTypeEnum.None)
                              this.childRegion.x1 = this.childRegion.x2 - childWidth;
                    }
                    else if (this.anchorRight == AnchorTypeEnum.Relative) {
                         this.childRegion.x2 = this.parent.width - (this.parent.width * (this.anchorRightValue / 100));

                         if (this.anchorLeft == AnchorTypeEnum.None)
                              this.childRegion.x1 = this.childRegion.x2 - childWidth;
                    }
                    else if (this.anchorRight == AnchorTypeEnum.Centered) {
                         this.childRegion.x2 = (this.parent.width - ((this.parent.width / 2) - (childWidth / 2))) + this.anchorRightValue;

                         if (this.anchorLeft == AnchorTypeEnum.None)
                              this.childRegion.x1 = this.childRegion.x2 - childWidth;
                    }

                    if (this.keepAspectRatio && this.anchorLeft != AnchorTypeEnum.None && this.anchorRight != AnchorTypeEnum.None) {

                         childWidth = Math.abs(this.childRegion.x2 - this.childRegion.x1);
                         childHeight = childWidth / childRatio;
                    }

                    //top
                    if (this.anchorTop == AnchorTypeEnum.Absolute) {
                         this.childRegion.y1 = this.anchorTopValue;

                         if (this.anchorBottom == AnchorTypeEnum.None) {
                              this.childRegion.y2 = this.childRegion.y1 + childHeight;
                         }
                    } else if (this.anchorTop == AnchorTypeEnum.Relative) {
                         this.childRegion.y1 = this.parent.height * (this.anchorTopValue / 100);
                         if (this.anchorBottom == AnchorTypeEnum.None) {
                              this.childRegion.y2 = this.childRegion.y1 + childHeight;
                         }
                    } else if (this.anchorTop == AnchorTypeEnum.Centered) {
                         this.childRegion.y1 = ((this.parent.height / 2) - (childHeight / 2)) - this.anchorTopValue;
                         if (this.anchorBottom == AnchorTypeEnum.None) {
                              this.childRegion.y2 = this.childRegion.y1 + childHeight;
                         }
                    }

                    //bottom
                    if (this.anchorBottom == AnchorTypeEnum.Absolute) {

                         this.childRegion.y2 = this.parent.height - this.anchorBottomValue;

                         if (this.anchorTop == AnchorTypeEnum.None) {
                              this.childRegion.y1 = this.childRegion.y2 - childHeight;
                         }

                    } else if (this.anchorBottom == AnchorTypeEnum.Relative) {
                         this.childRegion.y2 = this.parent.height - (this.parent.height * (this.anchorBottomValue / 100));
                         if (this.anchorTop == AnchorTypeEnum.None) {
                              this.childRegion.y1 = this.childRegion.y2 - childHeight;
                         }
                    } else if (this.anchorBottom == AnchorTypeEnum.Centered) {
                         this.childRegion.y2 = (this.parent.height - ((childHeight / 2) - (childHeight / 2))) + this.anchorBottomValue;
                         if (this.anchorTop == AnchorTypeEnum.None) {
                              this.childRegion.y1 = this.childRegion.y2 - childHeight;
                         }
                    }

                    if (this.anchorLeft != AnchorTypeEnum.None && this.anchorRight != AnchorTypeEnum.None &&
                         this.anchorTop != AnchorTypeEnum.None && this.anchorBottom != AnchorTypeEnum.None) {

                         childWidth = Math.abs(this.childRegion.x2 - this.childRegion.x1);
                         childHeight = Math.abs(this.childRegion.x2 - this.childRegion.x1);
                    }
                    else if (this.keepAspectRatio && this.anchorTop != AnchorTypeEnum.None && this.anchorBottom != AnchorTypeEnum.None) {

                         childHeight = Math.abs(this.childRegion.x2 - this.childRegion.x1);
                         childWidth = childRatio * childHeight;
                    }

                    this.child.setRegion(this.childRegion);

               }

          }

          return { TransformType, AnchorTypeEnum, AnchorTransformType }
     })();

     // Graphics module
     OneSparkJs.Canvas = (() => {
          let canvas = null;
          let context = null;
          let workCanvas = null;
          let workContext = null;
          let fullWindow = false;

          const initialize = (canvasId, useFullWindow) => {
               canvas = document.getElementById(canvasId);

               if (useFullWindow) {
                    fullWindow = true;
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
               }

               context = canvas.getContext("2d");
               workCanvas = document.createElement('canvas');
               workCanvas.width = canvas.width;
               workCanvas.height = canvas.height;
               workContext = workCanvas.getContext('2d');

               // Add an event listener to detect canvas resizing
               window.addEventListener('resize', () => {

                    if (fullWindow) {
                         canvas.width = window.innerWidth;
                         canvas.height = window.innerHeight;
                         context = canvas.getContext("2d");
                         workCanvas = document.createElement('canvas');
                         workCanvas.width = canvas.width;
                         workCanvas.height = canvas.height;
                         workContext = workCanvas.getContext('2d');
                    }

                    context = canvas.getContext("2d");
                    workCanvas = document.createElement('canvas');
                    workCanvas.width = canvas.width;
                    workCanvas.height = canvas.height;
                    workContext = workCanvas.getContext('2d');
                    OneSparkJs.Renderer.Ext.raiseResizeEvent(canvas.width, canvas.height);
               });
          };

          const getStyle = () => {
               return canvas.style;
          };

          const getSize = () => {
               return {
                    width: canvas.width,
                    height: canvas.height
               }
          };

          const getContext = () => {
               return workContext;
          };

          const publish = () => {
               context.clearRect(0, 0, canvas.width, canvas.height);
               context.drawImage(workCanvas, 0, 0);
          };

          const setState = (savedState) => {
               // Clear the canvas
               context.clearRect(0, 0, canvas.width, canvas.height);

               // Restore the saved state of the canvas
               const img = new Image();
               img.onload = function () {
                    context.drawImage(img, 0, 0);
               };
               img.src = savedState;
          };

          const getState = () => {
               // Save the current state of the canvas
               const savedState = canvas.toDataURL();

               return savedState;
          };

          //still experimental
          const setFullScreen = (fullScreenMode) => {

               if (fullScreenMode) {
                    // Enter full screen mode
                    if (canvas.requestFullscreen) {
                         canvas.requestFullscreen();
                    } else if (canvas.webkitRequestFullscreen) {
                         canvas.webkitRequestFullscreen();
                    } else if (canvas.msRequestFullscreen) {
                         canvas.msRequestFullscreen();
                    }

                    canvas.width = screen.width;
                    canvas.height = screen.height;
                    context = canvas.getContext("2d");
                    workCanvas = document.createElement('canvas');
                    workCanvas.width = canvas.width;
                    workCanvas.height = canvas.height;
                    workContext = workCanvas.getContext('2d');

               } else {

                    try {
                         // Exit full screen mode
                         if (document.exitFullscreen) {
                              document.exitFullscreen();
                         } else if (document.webkitExitFullscreen) {
                              document.webkitExitFullscreen();
                         } else if (document.msExitFullscreen) {
                              document.msExitFullscreen();
                         }
                    } catch { }

                    canvas.width = originalWidth;
                    canvas.height = originalHeight;
                    context = canvas.getContext("2d");
                    workCanvas = document.createElement('canvas');
                    workCanvas.width = canvas.width;
                    workCanvas.height = canvas.height;
                    workContext = workCanvas.getContext('2d');

               }
          };

          return {
               initialize,
               setFullScreen,
               getContext,
               publish,
               getState,
               setState,
               getStyle,
               getSize
          }

     })();

     // Public API
     global.$1S.Renderer = {
          Type: {
               Vertex: OneSparkJs.Renderer.Vertex,
               SortBy: OneSparkJs.Renderer.SortByEnum,
               Stage: OneSparkJs.Renderer.StageType,
               Render2D: {
                    AlignOn: OneSparkJs.Renderer2D.AlignOnEnum,
                    Orientation: OneSparkJs.Renderer2D.Orientation,
                    Prop: OneSparkJs.Renderer2D.StagePropType,
                    Sprite: OneSparkJs.Renderer2D.SpritePropType,
                    Tileset: OneSparkJs.Renderer2D.TilesetPropType,
                    Transform: {
                         TransformType: OneSparkJs.Renderer2DTransform.TransformType,
                         AnchorType: OneSparkJs.Renderer2DTransform.AnchorTypeEnum,
                         AnchorTransform: OneSparkJs.Renderer2DTransform.AnchorTransformType
                    }
               },
          },
          Canvas: {
               setState: OneSparkJs.Canvas.setState,
               getState: OneSparkJs.Canvas.getState,
               getContext: OneSparkJs.Canvas.getContext,
               getSize: OneSparkJs.Canvas.getSize,
               getStyle: OneSparkJs.Canvas.getStyle,
               publish: OneSparkJs.Canvas.publish,
               setFullScreen: OneSparkJs.Canvas.setFullScreen
          },
          register: OneSparkJs.Renderer.Ext.register,
          render: OneSparkJs.Renderer.Ext.render,
          destroy: OneSparkJs.Renderer.Ext.destroy,
          get: OneSparkJs.Renderer.Ext.get,
          getActiveName: OneSparkJs.Renderer.Ext.getActiveName,
          switchTo: OneSparkJs.Renderer.Ext.switchTo
     };

})(typeof window !== 'undefined' ? window : global);

((global) => {

     //right now physics assumes a centered alignment with a x/y scale = 1

     const OneSparkJs = {};

     OneSparkJs.Debug = true;

     OneSparkJs.Physics = (() => {

          class PhysicsModifierType {
               constructor(target, properties = {}) {

                    if (!(target instanceof PhysicsBound))
                         throw new Error("No PhysicsBound target provided.");

                    this.id = $1S.Helper.newId();

                    this.target = target;

                    if (this.onInit) this.onInit(properties);
               }

               onTick(timeStamp, deltaTime) {
                    throw new Error("onTick not implemented.");
               }
          }

          class CollisionModifierType {
               constructor(target, properties) {

                    if (!(target instanceof PhysicsBound))
                         throw new Error("No PhysicsBound target provided.");

                    this.id = $1S.Helper.newId();

                    this.target = target;

                    if (this.onInit) this.onInit(properties);
               }

               onCollision(collisionObjects) {
                    throw new Error("onCollision not defined.");
               }
          }

          class PhysicsBound extends $1S.Renderer.Type.Render2D.Prop {
               constructor(properties = {}) {
                    super(properties, true);

                    this.vectorX = properties.vectorX || 0;
                    this.vectorY = properties.vectorY || 0;
                    this.rotationSpeed = properties.rotationSpeed || 0;
                    this.vectorX2 = properties.vectorX || 0;
                    this.vectorY2 = properties.vectorY || 0;
                    this.rotationSpeed2 = properties.rotationSpeed || 0;
                    this.mass = properties.mass || 1;
                    this.takesCollisions = properties.takesCollisions || false;
                    this.givesCollisions = properties.givesCollisions || false;
                    this.collisionBorder = properties.collisionBorder || [];
                    this.physicsModifiers = [];
                    this.collisionModifiers = [];
                    this.collisions = [];

                    if (this.onInit) this.onInit(properties);

               }

               registerPhysicsModifier = (instance, priority = 100) => {
                    if (!(instance instanceof PhysicsModifierType))
                         throw new Error("Not a PhysicsModifierType component.");

                    this.physicsModifiers.push({
                         instance: instance,
                         Priority: priority
                    });

                    // Sort PhysicsModifiers by priority
                    this.physicsModifiers.sort((a, b) => a.Priority - b.Priority);
               }

               getPhysicsModifier = (id) => {

                    const subPhysicsModifiersObj = this.physicsModifiers.find(prop => prop.instance.id === id);

                    if (subPhysicsModifiersObj) {
                         return subPhysicsModifiersObj.instance;
                    }

                    return null;
               }

               destroyPhysicsModifier = (id) => {

                    const index = this.physicsModifiers.findIndex(prop => prop.instance.id === id);

                    if (index !== -1) {
                         if (this.physicsModifiers[i].onDestroy)
                              this.physicsModifiers[i].onDestroy();

                         this.physicsModifiers.splice(index, 1);
                         return true;
                    }

                    return false;
               }

               clearPhysicsModifiers = () => {
                    for (var i = 0; i < this.physicsModifiers.length; i++)
                         if (this.physicsModifiers[i].onDestroy)
                              this.physicsModifiers[i].onDestroy();

                    this.physicsModifiers[i] = [];
               }

               registerCollisionModifier = (instance, priority = 100) => {
                    if (!(instance instanceof CollisionModifierType))
                         throw new Error("Not a CollisionModifierType component.");

                    this.collisionModifiers.push({
                         instance: instance,
                         Priority: priority
                    });

                    // Sort CollisionModifiers by priority
                    this.collisionModifiers.sort((a, b) => a.Priority - b.Priority);
               }

               getCollisionModifier = (id) => {

                    const subCollisionModifiersObj = this.collisionModifiers.find(prop => prop.instance.id === id);

                    if (subCollisionModifiersObj) {
                         return subCollisionModifiersObj.instance;
                    }

                    return null;
               }

               destroyCollisionModifier = (id) => {

                    const index = this.collisionModifiers.findIndex(prop => prop.instance.id === id);

                    if (index !== -1) {
                         if (this.collisionModifiers[i].onDestroy)
                              this.collisionModifiers[i].onDestroy();

                         this.collisionModifiers.splice(index, 1);
                         return true;
                    }

                    return false;
               }

               clearCollisionModifiers = () => {
                    for (var i = 0; i < this.collisionModifiers.length; i++)
                         if (this.collisionModifiers[i].onDestroy)
                              this.collisionModifiers[i].onDestroy();

                    this.collisionModifiers[i] = [];
               }

               raiseTickEvent(timeStamp, deltaTime) {
                    super.raiseTickEvent(timeStamp, deltaTime);

                    if (!this.isActive) return;

                    for (var i = 0; i < this.physicsModifiers.length; i++)
                         this.physicsModifiers[i].instance.onTick(timeStamp, deltaTime);

                    // update position based on velocity
                    this.orientation.x += this.vectorX * deltaTime;
                    this.orientation.y += this.vectorY * deltaTime;
                    this.orientation.rotation += this.rotationSpeed * deltaTime;
               }

               raiseResizeEvent = (w, h) => {
                    super.raiseResizeEvent(w, h);

                    if (!this.isActive) return;

                    for (var i = 0; i < this.physicsModifiers.length; i++)
                         if (this.physicsModifiers[i].onResize)
                              this.physicsModifiers[i].instance.onResize(w, h);

               }

               raiseCollisionEvent(collisionObjects) {

                    if (this.onCollision)
                         this.onCollision(collisionObjects);

                    this.vectorX2 = this.vectorX;
                    this.vectorY2 = this.vectorY;
                    this.rotationSpeed2 = this.rotationSpeed;

                    for (var i = 0; i < this.collisionModifiers.length; i++)
                         this.collisionModifiers[i].instance.onCollision(collisionObjects);

                    //inform sub objects
                    for (var i = 0; i < this.stageProps.length; i++)
                         if (this.stageProps[i].instance.raiseCollisionEvent)
                              this.stageProps[i].instance.raiseCollisionEvent(collisionObjects);
               }

               raiseCollisionCommitEvent() {
                    this.vectorX = this.vectorX2;
                    this.vectorY = this.vectorY2;
                    this.rotationSpeed = this.rotationSpeed2;

                    //inform sub objects
                    for (var i = 0; i < this.stageProps.length; i++)
                         if (stageProps[i].instance.raiseCollisionCommitEvent)
                              this.stageProps[i].instance.raiseCollisionCommitEvent(collisionObjects);
               }

               raiseRenderEvent(context = null) {

                    if (OneSparkJs.Debug) {
                         if (this.collisionBorder) {
                              const shape = $1S.Physics.Collisions.getAbsoluteBorder(this.orientation.x, this.orientation.y, this.collisionBorder);
                              context.strokeStyle = 'red'; // Set the stroke color to red
                              context.lineWidth = 1; // Set the line width to 1 pixel

                              // Begin drawing the hexagon shape
                              context.beginPath();
                              context.moveTo(shape[0].orientation.x, shape[0].orientation.y); // Move to the first vertex
                              for (let i = 1; i < shape.length; i++) {
                                   context.lineTo(shape[i].orientation.x, shape[i].orientation.y); // Draw a line to each subsequent vertex
                              }
                              context.closePath(); // Close the path
                              context.stroke(); // Draw the stroke
                         }
                    }

                    super.raiseRenderEvent(context);
               }
          }

          class ThrustModifer extends PhysicsModifierType {

               onInit(properties) {
                    this.thrust = properties.acceleration; // acceleration in pixels/second^2
                    this.speedCap = properties.speedCap;
                    this.thrusts = {
                         up: false,
                         down: false,
                         left: false,
                         right: false,
                         forward: false,
                         backward: false
                    };
               }

               isAccelerating() {
                    return this.thrusts.up || this.thrusts.down || this.thrusts.left || this.thrusts.right || this.thrusts.forward || this.thrusts.backward;
               }

               moveForwardStart() {
                    this.thrusts.forward = true;
               }

               moveBackwardStart() {
                    this.thrusts.backward = true;
               }

               moveUpStart() {
                    this.thrusts.up = true;
               }

               moveDownStart() {
                    this.thrusts.down = true;
               }

               moveLeftStart() {
                    this.thrusts.left = true;
               }

               moveRightStart() {
                    this.thrusts.right = true;
               }

               moveForwardStop() {
                    this.thrusts.forward = false;
               }

               moveBackwardStop() {
                    this.thrusts.backward = false;
               }

               moveUpStop() {
                    this.thrusts.up = false;
               }

               moveDownStop() {
                    this.thrusts.down = false;
               }

               moveLeftStop() {
                    this.thrusts.left = false;
               }

               moveRightStop() {
                    this.thrusts.right = false;
               }

               onTick(timeStamp, deltaTime) {
                    let thrustCount = 0;
                    if (this.thrusts.up) thrustCount++;
                    if (this.thrusts.down) thrustCount++;
                    if (this.thrusts.left) thrustCount++;
                    if (this.thrusts.right) thrustCount++;
                    if (this.thrusts.forward) thrustCount++;
                    if (this.thrusts.backward) thrustCount++;

                    if (thrustCount > 0) {
                         const deltaAcc = this.thrust / thrustCount;

                         if (this.thrusts.up) this.target.vectorY -= deltaAcc;
                         if (this.thrusts.down) this.target.vectorY += deltaAcc;
                         if (this.thrusts.left) this.target.vectorX -= deltaAcc;
                         if (this.thrusts.right) this.target.vectorX += deltaAcc;

                         if (this.thrusts.forward) {
                              const angle = this.target.orientation.rotation * (Math.PI / 180);
                              this.target.vectorX += deltaAcc * Math.cos(angle);
                              this.target.vectorY += deltaAcc * Math.sin(angle);
                         }

                         if (this.thrusts.backward) {
                              const angle = this.target.orientation.rotation * (Math.PI / 180);
                              this.target.vectorX -= (deltaAcc * Math.cos(angle));
                              this.target.vectorY -= (deltaAcc * Math.sin(angle));
                         }

                         // Enforce speed limit
                         if (this.speedCap > 0) {
                              const currentSpeed = Math.sqrt(this.target.vectorX ** 2 + this.target.vectorY ** 2);
                              if (currentSpeed > this.speedCap) {
                                   const scaleFactor = this.speedCap / currentSpeed;
                                   this.target.vectorX *= scaleFactor;
                                   this.target.vectorY *= scaleFactor;
                              }
                         }
                    }
               }
          }

          class FrictionModifier extends PhysicsModifierType {

               onInit(properties) {
                    this.friction = properties.frictionCoefficient; // friction in pixels/second^2
               }

               onTick(timeStamp, deltaTime) {
                    // apply friction to slow down the velocity of the target object
                    const frictionX = this.target.vectorX > 0 ? -1 : 1;
                    const frictionY = this.target.vectorY > 0 ? -1 : 1;
                    const deltaVelX = Math.abs(this.target.vectorX) * this.friction * deltaTime * frictionX;
                    const deltaVelY = Math.abs(this.target.vectorY) * this.friction * deltaTime * frictionY;

                    if (Math.abs(deltaVelX) > Math.abs(this.target.vectorX)) {
                         this.target.vectorX = 0;
                    } else {
                         this.target.vectorX += deltaVelX;
                    }

                    if (Math.abs(deltaVelY) > Math.abs(this.target.vectorY)) {
                         this.target.vectorY = 0;
                    } else {
                         this.target.vectorY += deltaVelY;
                    }
               }
          }

          class EnvironmentalGravityModifier extends PhysicsModifierType {

               onInit(properties) {
                    this.gravity = properties.gravity; // gravity in pixels/second^2
                    this.direction = properties.direction; // normalized vector representing the direction of gravity force
               }

               onTick(timeStamp, deltaTime) {
                    // apply gravity force to accelerate the target object
                    const gravityForceX = this.direction.x * this.gravity;
                    const gravityForceY = this.direction.y * this.gravity;
                    const deltaVelX = gravityForceX * deltaTime;
                    const deltaVelY = gravityForceY * deltaTime;

                    this.target.vectorX += deltaVelX;
                    this.target.vectorY += deltaVelY;
               }
          }

          class GravitationalAttractionModifier extends PhysicsModifierType {
               
               onInit(properties) {
                    this.gravityConstant = properties.gravityConstant;
               }

               onTick(timeStamp, deltaTime) {
                    var stage = $1S.Renderer.get();

                    var stageObjects = stage.instance.stageProps;

                    for (var i = 0; i < stageObjects.length; i++) {
                         var stageObject = stageObjects[i].instance;

                         if (stageObject instanceof PhysicsBound) {

                              var mass = stageObject.mass;
                              var x = stageObject.orientation.x;
                              var y = stageObject.orientation.y;

                              if (stageObject.id !== this.target.id) {

                                   // calculate distance between target and stage object
                                   var distX = x - this.target.orientation.x;
                                   var distY = y - this.target.orientation.y;
                                   var distance = Math.sqrt(distX * distX + distY * distY);

                                   if (distance != 0) {
                                        // calculate gravitational force on target
                                        var force = (this.gravityConstant * mass) / (distance);
                                        var forceX = force * distX / distance;
                                        var forceY = force * distY / distance;

                                        // apply force to target
                                        this.target.vectorX += forceX * deltaTime;
                                        this.target.vectorY += forceY * deltaTime;
                                   }
                              }

                         }
                    }
               }

          }

          class BounceModifier extends PhysicsModifierType {

               onInit(properties) {
                    this.width = properties.width;
                    this.height = properties.height;
                    this.bounceReduction = properties.bounceReduction;
               }

               onTick(timeStamp, deltaTime) {
                    // check if the target object has hit the left or right side of the canvas
                    if (this.target.orientation.x - this.target.width / 2 < 0) {
                         this.target.orientation.x = this.target.width / 2;
                         this.target.vectorX = -this.target.vectorX;
                    } else if (this.target.orientation.x + this.target.width / 2 > this.width) {
                         this.target.orientation.x = this.width - this.target.width / 2;
                         this.target.vectorX = -this.target.vectorX;
                    }

                    // check if the target object has hit the top or bottom of the canvas
                    if (this.target.orientation.y - this.target.height / 2 < 0) {
                         this.target.orientation.y = this.target.height / 2;
                         this.target.vectorY = -this.target.vectorY;
                    } else if (this.target.orientation.y + this.target.height / 2 > this.height) {
                         this.target.orientation.y = this.height - this.target.height / 2;
                         this.target.vectorY = -this.target.vectorY + this.bounceReduction;
                         if (this.target.vectorY > 0) this.target.vectorY = 0;
                    }
               }
          }

          class WrapAroundModifier extends PhysicsModifierType {

               onInit(properties) {
                    this.width = properties.width;
                    this.height = properties.height;
               }

               onTick(timeStamp, deltaTime) {
                    if (this.target.orientation.x < -this.target.width / 2) {
                         this.target.orientation.x = this.width + this.target.width / 2;
                    } else if (this.target.orientation.x > this.width + this.target.width / 2) {
                         this.target.orientation.x = -this.target.width / 2;
                    }

                    if (this.target.orientation.y < -this.target.height / 2) {
                         this.target.orientation.y = this.height + this.target.height / 2;
                    } else if (this.target.orientation.y > this.height + this.target.height / 2) {
                         this.target.orientation.y = -this.target.height / 2;
                    }
               }
          }

          class RotateTowardsVectorModifier extends PhysicsModifierType {

               onInit(properties) {
                    this.active = true;
                    this.rotationSpeed = properties.rotationSpeed; // default rotation speed
               }

               onTick(timeStamp, deltaTime) {
                    if (this.active) {
                         // calculate the angle between the current rotation and the target vector
                         const targetAngle = Math.atan2(this.target.vectorY, this.target.vectorX);
                         const currentAngle = targetAngle * 180 / Math.PI;

                         this.target.rotationSpeed = 0;
                         this.target.orientation.rotation = currentAngle;
                    }
               }
          }

          class BounceCollision extends CollisionModifierType {

               onCollision(collisionObjects) {

                    for (let i = 0; i < collisionObjects.length; i++) {
                         const collisionObject = collisionObjects[i];

                         const totalMass = this.target.mass + collisionObject.mass;

                         // calculate the new velocity components for objectVector1 after collision
                         const newVelX1 = (this.target.mass - collisionObject.mass) / totalMass * this.target.vectorX2 +
                              (2 * collisionObject.mass / totalMass) * collisionObject.vectorX;
                         const newVelY1 = (this.target.mass - collisionObject.mass) / totalMass * this.target.vectorY2 +
                              (2 * collisionObject.mass / totalMass) * collisionObject.vectorY;

                         this.target.vectorX2 = newVelX1;
                         this.target.vectorY2 = newVelY1;
                    }
               }

          }

          class Extension extends $1S.Application.ExtensionType {

               constructor() {
                    super(0);
               };

               onLoad = (appPath, properties, oncomplete) => {
                    //does nothing for now
                    oncomplete();
               }

               handlePostTickEvent = (timeStamp, deltaTime) => {
                    this.detectCollisions();
               }

               detectCollisions = () => {

                    const stage = $1S.Renderer.get();

                    if (!stage) return;

                    var pendingCommits = [];

                    // Find objects that give and take collisions
                    const givesCollisions = stage.instance.stageProps.filter(prop => prop.instance instanceof $1S.Physics.Type.PhysicsBound && prop.instance.givesCollisions);
                    const takesCollisions = stage.instance.stageProps.filter(prop => prop.instance instanceof $1S.Physics.Type.PhysicsBound && prop.instance.takesCollisions);

                    // Check for collisions
                    for (const takes of takesCollisions) {

                         const takesBorder = this.getAbsoluteBorder(takes.instance.orientation.x + (takes.instance.width / 2), takes.instance.orientation.y + (takes.instance.height / 2), takes.instance.collisionBorder);

                         const collisions = givesCollisions
                              .filter(gives => takes.instance.id !== gives.instance.id)
                              .filter(gives => this.doPolygonsIntersect(takesBorder, this.getAbsoluteBorder(gives.instance.orientation.x + (gives.instance.width / 2), gives.instance.orientation.y + (gives.instance.height / 2), gives.instance.collisionBorder)))
                              .map(gives => gives.instance);

                         const newCollisions = collisions.filter(collision => !takes.instance.collisions.includes(collision.id));

                         takes.instance.collisions = [...new Set([...takes.instance.collisions.filter(collisionId => collisions.some(collision => collision.id === collisionId)), ...collisions.map(collision => collision.id)])];

                         if (newCollisions.length > 0) {
                              pendingCommits.push(takes);
                              takes.instance.raiseCollisionEvent(newCollisions);
                         }
                    }

                    for (const pending of pendingCommits) {
                         pending.instance.raiseCollisionCommitEvent();
                    }

               }

               getAbsoluteBorder = (midX, midY, relBorder) => {
                    const absBorder = [];
                    for (let i = 0; i < relBorder.length; i++) {
                         const x = midX + relBorder[i].x;
                         const y = midY + relBorder[i].y;
                         absBorder.push({ x, y });
                    }
                    return absBorder;
               }

               createCollisionBorderBox = (width, height) => {
                    return [
                         { x: +(width / 2), y: -(height / 2) },
                         { x: +(width / 2), y: +(height / 2) },
                         { x: -(width / 2), y: +(height / 2) },
                         { x: -(width / 2), y: -(height / 2) }
                    ];
               }

               createCollisionBorderHexagon = (width, height) => {
                    return [
                         { x: -(width / 2 + 2), y: 0 },
                         { x: -(width / 4 + 1), y: (height / 2 + 1) },
                         { x: width / 4 + 1, y: (height / 2 + 1) },
                         { x: width / 2 + 2, y: 0 },
                         { x: width / 4 + 1, y: -(height / 2 + 1) },
                         { x: -(width / 4 + 1), y: -(height / 2 + 1) }
                    ];
               }

               doPolygonsIntersect = (pg1, pg2) => {
                    // Check if any of the edges overlap
                    for (let i = 0; i < pg1.length; i++) {
                         const p1 = pg1[i];
                         const p2 = i === pg1.length - 1 ? pg1[0] : pg1[i + 1];
                         for (let j = 0; j < pg2.length; j++) {
                              const q1 = pg2[j];
                              const q2 = j === pg2.length - 1 ? pg2[0] : pg2[j + 1];
                              if (this.doLinesIntersect(p1, p2, q1, q2)) {
                                   return true;
                              }
                         }
                    }

                    // Check if one polygon is inside the other
                    if (this.isPointInsidePolygon(pg1[0], pg2) || this.isPointInsidePolygon(pg2[0], pg1)) {
                         return true;
                    }

                    // If we made it this far, the polygons don't intersect
                    return false;
               }

               doLinesIntersect = (p1, p2, q1, q2) => {
                    // Calculate the direction of the lines
                    const dirP = { x: p2.x - p1.x, y: p2.y - p1.y };
                    const dirQ = { x: q2.x - q1.x, y: q2.y - q1.y };

                    // Calculate the determinant of the matrix formed by the direction vectors
                    const det = dirP.x * dirQ.y - dirP.y * dirQ.x;

                    // If the determinant is zero, the lines are parallel
                    if (det === 0) {
                         return false;
                    }

                    // Calculate the intersection point of the lines
                    const dx = q1.x - p1.x;
                    const dy = q1.y - p1.y;
                    const t = (dx * dirQ.y - dy * dirQ.x) / det;
                    const u = (dx * dirP.y - dy * dirP.x) / det;

                    // If the intersection point is on both lines, they intersect
                    return t >= 0 && t <= 1 && u >= 0 && u <= 1;
               }

               isPointInsidePolygon = (point, polygon) => {
                    let inside = false;
                    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                         const pi = polygon[i];
                         const pj = polygon[j];
                         const intersect = (pi.y > point.y) !== (pj.y > point.y) &&
                              (point.x < (pj.x - pi.x) * (point.y - pi.y) / (pj.y - pi.y) + pi.x);
                         if (intersect) {
                              inside = !inside;
                         }
                    }
                    return inside;
               }

          }

          const Ext = new Extension();

          return {
               PhysicsBound,
               ThrustModifer,
               EnvironmentalGravityModifier,
               GravitationalAttractionModifier,
               FrictionModifier,
               BounceModifier,
               WrapAroundModifier,
               RotateTowardsVectorModifier,
               BounceCollision,
               Ext
          }
     })();

     // Public API
     global.$1S.Physics = {
          Type: {
               PhysicsBound: OneSparkJs.Physics.PhysicsBound
          },
          Motion: {
               Thrust: OneSparkJs.Physics.ThrustModifer,
               Friction: OneSparkJs.Physics.FrictionModifier,
               EnvironmentalGravity: OneSparkJs.Physics.EnvironmentalGravityModifier,
               GravitationalAttraction: OneSparkJs.Physics.GravitationalAttractionModifier,
               Bounce: OneSparkJs.Physics.BounceModifier,
               WrapAround: OneSparkJs.Physics.WrapAroundModifier,
               RotateTowardsVector: OneSparkJs.Physics.RotateTowardsVectorModifier
          },
          Collisions: {
               Modifiers: {
                    Bounce: OneSparkJs.Physics.BounceCollision
               },
               createBox: OneSparkJs.Physics.Ext.createCollisionBorderBox,
               createHexagon: OneSparkJs.Physics.Ext.createCollisionBorderHexagon,
               getAbsoluteBorder: OneSparkJs.Physics.Ext.getAbsoluteBorder
          },
          Spacial: {
               doPolygonsIntersect: OneSparkJs.Physics.Ext.doPolygonsIntersect,
               doLinesIntersect: OneSparkJs.Physics.Ext.doLinesIntersect,
               isPointInsidePolygon: OneSparkJs.Physics.Ext.doPolygonsOverlap
          }
     };

})(typeof window !== 'undefined' ? window : global);

((global) => {

     const OneSparkJs = {};

     OneSparkJs.UI = (() => {

          class UiType extends $1S.Renderer.Type.Render2D.Prop {

               constructor(properties = {}) {
                    super(properties);

                    this.backColor = properties.backColor || 'transparent';
                    this.textColor = properties.textColor || 'black';
                    this.fontSize = properties.fontSize || 16;
                    this.fontFamily = properties.fontFamily || 'Arial';
                    this.textAlign = properties.textAlign || 'left';
                    this.isFocused = false;

                    if (this.onInit) this.onInit(properties);
               }

               registerProp = (instance, properties = {}, priority = 0) => {
                    if (!(instance instanceof UiType))
                         throw new Error("Not a UiType component.");

                    super.registerProp(instance, properties = {}, priority + 100000);
               }


               onDraw(context) {
                    context.clearRect(0, 0, this.width, this.height);

                    context.fillStyle = this.backColor;
                    context.fillRect(0, 0, this.width, this.height);
               }

          }

          class TextBoxControl extends UiType {

               //Run on init
               onInit(properties) {
                    this.text = properties.text || '';
                    this.isEditable = properties.isEditable !== undefined ? properties.isEditable : true;
                    this.cursorPosition = 0;
                    this.cursorBlinkInterval = null;
                    this.cursorVisible = false;
                    this.cursorColor = properties.cursorColor || 'black';

                    this.region = this.getRegion();
               }

               //Control is showing
               onShowStage() {
                    const region = this.region;

                    $1S.IO.Input.attach($1S.IO.Input.EventType.MOUSE_MOVE,
                         this.id,
                         (event) => {
                              $1S.Renderer.Canvas.getStyle().cursor = "pointer";
                              return true;
                         },
                         100, region);


                    $1S.IO.Input.attach($1S.IO.Input.EventType.MOUSE_ENTER,
                         this.id,
                         (event) => {
                              $1S.Renderer.Canvas.getStyle().cursor = "pointer";
                              return true;
                         },
                         100, region);

                    $1S.IO.Input.attach($1S.IO.Input.EventType.MOUSE_LEAVE,
                         this.id,
                         (event) => {
                              $1S.Renderer.Canvas.getStyle().cursor = "default";
                              return true;
                         },
                         100, region);

                    $1S.IO.Input.attach($1S.IO.Input.EventType.MOUSE_CLICK,
                         this.id,
                         (event) => {
                              this.isFocused = true;
                              this.setCursorPosition(event.offsetX);
                              this.startCursorBlinking();
                              return true;
                         },
                         100, region);

                    $1S.IO.Input.attach($1S.IO.Input.EventType.TAP,
                         this.id,
                         (event) => {
                              this.isFocused = true;
                              this.setCursorPosition(event.offsetX);
                              this.startCursorBlinking();
                              return true;
                         },
                         100, region);

                    $1S.IO.Input.attach($1S.IO.Input.EventType.MOUSE_CLICK_OUT,
                         this.id,
                         (event) => {
                              this.isFocused = false;
                              this.stopCursorBlinking();
                              return true;
                         },
                         100, region);

                    $1S.IO.Input.attach($1S.IO.Input.EventType.TAP_OUT,
                         this.id,
                         (event) => {
                              this.isFocused = false;
                              this.stopCursorBlinking();
                              return true;
                         },
                         100, region);

                    $1S.IO.Input.attach($1S.IO.Input.EventType.KEY_DOWN,
                         this.id,
                         (event) => {
                              if (this.isEditable && this.isFocused) {
                                   event.preventDefault();
                                   switch (event.keyCode) {
                                        case 8: // Backspace
                                             if (this.cursorPosition > 0) {
                                                  this.text = this.text.slice(0, this.cursorPosition - 1) + this.text.slice(this.cursorPosition);
                                                  this.cursorPosition--;
                                             }
                                             break;
                                        case 46: // Delete
                                             if (this.cursorPosition < this.text.length) {
                                                  this.text = this.text.slice(0, this.cursorPosition) + this.text.slice(this.cursorPosition + 1);
                                             }
                                             break;
                                        case 37: // Left arrow
                                             if (this.cursorPosition > 0) {
                                                  this.cursorPosition--;
                                             }
                                             break;
                                        case 39: // Right arrow
                                             if (this.cursorPosition < this.text.length) {
                                                  this.cursorPosition++;
                                             }
                                             break;
                                        default:
                                             if (event.key.length === 1) {
                                                  this.text = this.text.slice(0, this.cursorPosition) + event.key + this.text.slice(this.cursorPosition);
                                                  this.cursorPosition++;
                                             }
                                             break;
                                   }
                              }
                              return true;
                         });
               }

               //Control is hiddden
               onHideStage() {
                    this.onDispose();
               }

               //Destroying component
               onDispose() {
                    $1S.Renderer.Canvas.getStyle().cursor = "default";
                    $1S.IO.Input.release(this.id);
               }

               //Draw component on context
               onDraw(context) {

                    context.clearRect(0, 0, this.width, this.height);

                    context.fillStyle = this.backColor;
                    context.fillRect(0, 0, this.width, this.height);

                    context.font = `${this.fontSize}px ${this.fontFamily}`;
                    context.fillStyle = this.textColor;
                    context.textBaseline = "middle";

                    const metrics = context.measureText(this.text); 
                    const fontHeight = metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent;

                    context.fillText(this.text, 0, this.height / 2);

                    if (this.isEditable && this.isFocused && this.cursorVisible) {
                         const cursorX = this.getXPositionForCursorPosition(this.cursorPosition);
                         const cursorY = this.height / 2 - fontHeight / 2;
                         context.strokeStyle = this.cursorColor;
                         context.beginPath();
                         context.moveTo(cursorX, cursorY);
                         context.lineTo(cursorX, cursorY + fontHeight);
                         context.stroke();
                    }

               }

               //private methods
               setCursorPosition(x) {
                    const localX = x - this.region.x1;

                    let minDistance = Infinity;
                    let nearestPosition = 0;

                    for (let i = 0; i <= this.text.length; i++) {
                         const distance = Math.abs(this.getXPositionForCursorPosition(i) - localX);

                         if (distance < minDistance) {
                              minDistance = distance;
                              nearestPosition = i;
                         }
                    }

                    this.cursorPosition = nearestPosition;
               }

               getXPositionForCursorPosition(position) {
                    const textBeforeCursor = this.text.slice(0, position);
                    const context = this.workContext;
                    const textWidth = context.measureText(textBeforeCursor).width;
                    return textWidth;
               }

               startCursorBlinking() {
                    this.cursorVisible = true;
                    this.cursorBlinkInterval = setInterval(() => {
                         this.cursorVisible = !this.cursorVisible;
                    }, 500);
               }

               stopCursorBlinking() {
                    this.isFocused = false;
                    clearInterval(this.cursorBlinkInterval);
                    this.cursorBlinkInterval = null;
                    this.cursorVisible = false;
               }

          }

          class LabelControl extends UiType {

               onInit(properties) {
                    this.text = properties.text || '';
               }

               onDraw(context) {
                    super.onDraw(context);

                    context.font = `${this.fontSize}px ${this.fontFamily}`;
                    context.fillStyle = this.textColor;
                    context.textBaseline = "middle";

                    if (this.textAlign == "center") {
                         const textWidth = context.measureText(this.text).width;
                         context.fillText(this.text, (this.width - textWidth) / 2, this.height / 2, this.width);
                    }
                    else if (this.textAlign == "right")
                    {
                         const textWidth = context.measureText(this.text).width;
                         context.fillText(this.text, this.width - textWidth, this.height / 2, this.width);
                    }
                    else
                         context.fillText(this.text, 0, this.height / 2, this.width);

               }
          }

          class ButtonControl extends UiType {

               onInit(properties) {
                    this.text = properties.text || '';
                    this.onClickHandler = properties.onClick || null;
                    this.state = null;
                    this.stateIsDown = false;
               }

               onShowStage() {
                    const region = this.getRegion();

                    //TODO:right now the mouse_enter and mouse_leave need this event subscribedd to.  fix this.
                    $1S.IO.Input.attach($1S.IO.Input.EventType.MOUSE_MOVE,
                         this.id,
                         (event) => {
                              $1S.Renderer.Canvas.getStyle().cursor = "pointer";
                              return true;
                         },
                         100, region);


                    $1S.IO.Input.attach($1S.IO.Input.EventType.MOUSE_ENTER,
                         this.id,
                         (event) => {
                              $1S.Renderer.Canvas.getStyle().cursor = "pointer";
                              return true;
                         },
                         100, region);

                    $1S.IO.Input.attach($1S.IO.Input.EventType.MOUSE_LEAVE,
                         this.id,
                         (event) => {
                              $1S.Renderer.Canvas.getStyle().cursor = "default";
                              return true;
                         },
                         100, region);

                    $1S.IO.Input.attach($1S.IO.Input.EventType.MOUSE_CLICK,
                         this.id,
                         (event) => {
                              this.state = "down";
                              if (this.onClickHandler) {

                                   if (this.clickTimeout) {
                                        clearTimeout(this.clickTimeout);
                                   }
                                   this.clickTimeout = setTimeout(() => {
                                        this.onClickHandler(this);
                                        this.clickTimeout = null;
                                   }, 100);

                              }
                              return true;
                         },
                         100, region);

                    $1S.IO.Input.attach($1S.IO.Input.EventType.TAP,
                         this.id,
                         (event) => {
                              if (this.onClickHandler) {

                                   if (this.clickTimeout) {
                                        clearTimeout(this.clickTimeout);
                                   }
                                   this.clickTimeout = setTimeout(() => {
                                        this.onClickHandler(this);
                                        this.clickTimeout = null;
                                   }, 100);

                              }
                              return true;
                         },
                         100, region);

                    $1S.IO.Input.attach($1S.IO.Input.EventType.MOUSE_UP,
                         this.id,
                         (event) => {
                              if (this.stateIsDown)
                                   this.state = "up";
                              return true;
                         },
                         100, region);
               }

               onHideStage() {
                    this.onDispose();
               }

               onDraw(context) {
                    super.onDraw(context);

                    context.font = `${this.fontSize}px ${this.fontFamily}`;
                    context.fillStyle = this.textColor;
                    context.textBaseline = "middle";

                    if (this.state == "down") {
                         this.orientation.x += 2;
                         this.orientation.y += 2;
                         this.state = null;
                         this.stateIsDown = true;
                    }
                    else if (this.state == "up") {
                         this.orientation.x -= 2;
                         this.orientation.y -= 2;
                         this.state = null;
                         this.stateIsDown = false;
                    }

                    const textWidth = context.measureText(this.text).width;

                    context.fillText(this.text, (this.width - textWidth) / 2, this.height / 2, this.width);

               }

               onDispose() {
                    $1S.Renderer.Canvas.getStyle().cursor = "default";
                    $1S.IO.Input.release(this.id);
               }
          }

          class MoveToModifer {
               constructor(target) {
                    this.target = target;
                    this.speed = 0; // current movement speed
                    this.milliSeconds = 0; // time to reach target position
                    this.startX = 0; // starting x position
                    this.startY = 0; // starting y position
                    this.targetX = 0; // target x position
                    this.targetY = 0; // target y position
                    this.callback = null; // callback function to be called when move is complete
               }

               onRender(context) {
                    //does nothing
               }

               moveToPosition(x, y, ms, callback) {
                    this.startX = this.target.orientation.x;
                    this.startY = this.target.orientation.y;
                    this.targetX = x;
                    this.targetY = y;
                    this.milliSeconds = ms;
                    const distance = Math.sqrt((x - this.target.orientation.x) ** 2 + (y - this.target.orientation.y) ** 2);
                    this.speed = distance / ms;
                    this.callback = callback;
               }

               onTick(timeStamp, deltaTime) {

                    if (this.target.orientation.x == this.targetX && this.target.orientation.y == this.targetY)
                         return;

                    const elapsedTime = deltaTime;
                    const deltaX = this.targetX - this.target.orientation.x;
                    const deltaY = this.targetY - this.target.orientation.y;
                    const distance = Math.sqrt(deltaX ** 2 + deltaY ** 2);

                    if (distance > 0) {
                         const moveDistance = this.speed * elapsedTime;
                         if (moveDistance >= distance) {
                              this.target.orientation.x = this.targetX;
                              this.target.orientation.y = this.targetY;
                              this.speed = 0;
                              if (this.callback) {
                                   this.callback();
                              }
                         } else {
                              const moveX = (deltaX / distance) * moveDistance;
                              const moveY = (deltaY / distance) * moveDistance;
                              this.target.orientation.x += moveX;
                              this.target.orientation.y += moveY;
                         }
                    }
               }
          }

          class Extension extends $1S.Application.ExtensionType {

               constructor() {
                    super(0);
               };

               onLoad = (appPath, properties, oncomplete) => {
                    //does nothing for now
                    oncomplete();
               }

               onTick = (timeStamp, deltaTime) => {
                    throw new Error("onTick not implemented");
               }
          }

          const Ext = new Extension();

          return {
               UiType,
               MoveToModifer,
               LabelControl,
               TextBoxControl,
               ButtonControl,
               Ext
          }
     })();

     // Public API
     global.$1S.UI = {
          UiType: OneSparkJs.UI.UiType,
          Animate: {
               moveTo: OneSparkJs.UI.MoveToModifer,
               fade: OneSparkJs.UI.FadeModifer
          },
          Controls: {
               TextBox: OneSparkJs.UI.TextBoxControl,
               Button: OneSparkJs.UI.ButtonControl,
               Label: OneSparkJs.UI.LabelControl
          }
     };



})(typeof window !== 'undefined' ? window : global);
